{"version":3,"file":"175.481259f6.iframe.bundle.js","mappings":";;;;;;;;;AA6EA;;;;;ACzDA;ACnBA;;AAEA;AACA;ACHA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAEA;;ACzYA;;;;AC6DA;ACqBA;;AAEA;;;;;AAQA;ACtEA;;AAEA;;AAkEA;;;;AAoBA;;;;AAYA;;;;ACtEA;ACgDA;;;AAIA;AAKA;;;AAIA;;;AC3GA;;;;;ACGA;;;ACOA;ACOA;;;;;AAMA;;;;ACoCA;ACwCA;;;;;;AClCA;;AAsNA;;;;ACtPA;;;;AA6DA;AACA;;;;AAUA;;AAwSA;;;;ACxZA","sources":["webpack://storybook-demo/./node_modules/@storybook/addon-actions/dist/esm/preview/withActions.js","webpack://storybook-demo/./node_modules/@storybook/addon-backgrounds/dist/preview.mjs","webpack://storybook-demo/./node_modules/@storybook/addon-backgrounds/dist/chunk-OCW2MZFJ.mjs","webpack://storybook-demo/./node_modules/@storybook/addon-outline/dist/preset/preview.mjs","webpack://storybook-demo/./node_modules/@storybook/builder-webpack5/node_modules/@storybook/channels/dist/index.mjs","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/autoTitle.js","webpack://storybook-demo/./node_modules/@storybook/client-api/dist/esm/StoryStoreFacade.js","webpack://storybook-demo/./node_modules/@storybook/client-api/dist/esm/ClientApi.js","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/StoryIndexStore.js","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/args.js","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/GlobalsStore.js","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/csf/normalizeStory.js","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/csf/prepareStory.js","webpack://storybook-demo/./node_modules/@storybook/store/dist/esm/inferArgTypes.js","webpack://storybook-demo/./node_modules/@storybook/preview-web/dist/esm/parseArgsParam.js","webpack://storybook-demo/./node_modules/@storybook/preview-web/dist/esm/WebView.js","webpack://storybook-demo/./node_modules/@storybook/preview-web/dist/esm/Preview.js","webpack://storybook-demo/./node_modules/@storybook/preview-web/dist/esm/PreviewWeb.js","webpack://storybook-demo/./node_modules/@storybook/react/dist/config.mjs"],"sourcesContent":["// Based on http://backbonejs.org/docs/backbone.html#section-164\nimport global from 'global';\nimport { useEffect, makeDecorator } from '@storybook/addons';\nimport deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport { actions } from './actions';\nimport { PARAM_KEY } from '../constants';\nconst {\n  document,\n  Element\n} = global;\nconst delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\nconst isIE = Element != null && !Element.prototype.matches;\nconst matchesMethod = isIE ? 'msMatchesSelector' : 'matches';\n\nconst hasMatchInAncestry = (element, selector) => {\n  if (element[matchesMethod](selector)) {\n    return true;\n  }\n\n  const parent = element.parentElement;\n\n  if (!parent) {\n    return false;\n  }\n\n  return hasMatchInAncestry(parent, selector);\n};\n\nconst createHandlers = (actionsFn, ...handles) => {\n  const actionsObject = actionsFn(...handles);\n  return Object.entries(actionsObject).map(([key, action]) => {\n    const [_, eventName, selector] = key.match(delegateEventSplitter) || [];\n    return {\n      eventName,\n      handler: e => {\n        if (!selector || hasMatchInAncestry(e.target, selector)) {\n          action(e);\n        }\n      }\n    };\n  });\n};\n\nconst applyEventHandlers = deprecate((actionsFn, ...handles) => {\n  const root = document && document.getElementById('storybook-root');\n  useEffect(() => {\n    if (root != null) {\n      const handlers = createHandlers(actionsFn, ...handles);\n      handlers.forEach(({\n        eventName,\n        handler\n      }) => root.addEventListener(eventName, handler));\n      return () => handlers.forEach(({\n        eventName,\n        handler\n      }) => root.removeEventListener(eventName, handler));\n    }\n\n    return undefined;\n  }, [root, actionsFn, handles]);\n}, dedent`\n    withActions(options) is deprecated, please configure addon-actions using the addParameter api:\n\n    addParameters({\n      actions: {\n        handles: options\n      },\n    });\n  `);\n\nconst applyDeprecatedOptions = (actionsFn, options) => {\n  if (options) {\n    applyEventHandlers(actionsFn, options);\n  }\n};\n\nexport const withActions = makeDecorator({\n  name: 'withActions',\n  parameterName: PARAM_KEY,\n  skipIfNoParametersOrOptions: true,\n  wrapper: (getStory, context, {\n    parameters,\n    options\n  }) => {\n    applyDeprecatedOptions(actions, options);\n    if (parameters && parameters.handles) applyEventHandlers(actions, ...parameters.handles);\n    return getStory(context);\n  }\n});","import{b as d,c as S,d as $,e as m,f as A,g as x}from\"./chunk-OCW2MZFJ.mjs\";import{useMemo as f,useEffect as v}from\"@storybook/addons\";var h=(g,r)=>{let{globals:b,parameters:t}=r,a=b[d]?.value,n=t[d],e=f(()=>n.disable?\"transparent\":$(a,n.values,n.default),[n,a]),c=f(()=>e&&e!==\"transparent\",[e]),s=r.viewMode===\"docs\"?`#anchor--${r.id} .docs-story`:\".sb-show-main\",i=f(()=>{let o=\"transition: background-color 0.3s;\";return`\n      ${s} {\n        background: ${e} !important;\n        ${S()?\"\":o}\n      }\n    `},[e,s]);return v(()=>{let o=r.viewMode===\"docs\"?`addon-backgrounds-docs-${r.id}`:\"addon-backgrounds-color\";if(!c){m(o);return}x(o,i,r.viewMode===\"docs\"?r.id:null)},[c,i,r]),g()};import{dedent as z}from\"ts-dedent\";import C from\"util-deprecate\";import{useMemo as B,useEffect as P}from\"@storybook/addons\";var R=C(()=>{},z`\n    Backgrounds Addon: The cell size parameter has been changed.\n\n    - parameters.grid.cellSize should now be parameters.backgrounds.grid.cellSize\n    See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-grid-parameter\n  `),F=(g,r)=>{let{globals:b,parameters:t}=r,a=t[d].grid,n=b[d]?.grid===!0&&a.disable!==!0,{cellAmount:e,cellSize:c,opacity:s}=a,i=r.viewMode===\"docs\",o;t.grid?.cellSize?(o=t.grid.cellSize,R()):o=c;let y=t.layout===void 0||t.layout===\"padded\"?16:0,l=a.offsetX??(i?20:y),p=a.offsetY??(i?20:y),k=B(()=>{let u=r.viewMode===\"docs\"?`#anchor--${r.id} .docs-story`:\".sb-show-main\",M=[`${o*e}px ${o*e}px`,`${o*e}px ${o*e}px`,`${o}px ${o}px`,`${o}px ${o}px`].join(\", \");return`\n      ${u} {\n        background-size: ${M} !important;\n        background-position: ${l}px ${p}px, ${l}px ${p}px, ${l}px ${p}px, ${l}px ${p}px !important;\n        background-blend-mode: difference !important;\n        background-image: linear-gradient(rgba(130, 130, 130, ${s}) 1px, transparent 1px),\n         linear-gradient(90deg, rgba(130, 130, 130, ${s}) 1px, transparent 1px),\n         linear-gradient(rgba(130, 130, 130, ${s/2}) 1px, transparent 1px),\n         linear-gradient(90deg, rgba(130, 130, 130, ${s/2}) 1px, transparent 1px) !important;\n      }\n    `},[o]);return P(()=>{let u=r.viewMode===\"docs\"?`addon-backgrounds-grid-docs-${r.id}`:\"addon-backgrounds-grid\";if(!n){m(u);return}A(u,k)},[n,k,r]),g()};var X=[F,h],W={backgrounds:{grid:{cellSize:20,opacity:.5,cellAmount:5},values:[{name:\"light\",value:\"#F8F8F8\"},{name:\"dark\",value:\"#333333\"}]}};export{X as decorators,W as parameters};\n","var l=\"storybook/background\",u=\"backgrounds\";var y={UPDATE:`${l}/update`};import c from\"global\";import{dedent as g}from\"ts-dedent\";import{logger as m}from\"@storybook/client-logger\";var{document:i,window:p}=c,B=()=>p.matchMedia(\"(prefers-reduced-motion: reduce)\").matches,H=(e,t=[],n)=>{if(e===\"transparent\")return\"transparent\";if(t.find(o=>o.value===e))return e;let r=t.find(o=>o.name===n);if(r)return r.value;if(n){let o=t.map(s=>s.name).join(\", \");m.warn(g`\n        Backgrounds Addon: could not find the default color \"${n}\".\n        These are the available colors for your story based on your configuration:\n        ${o}.\n      `)}return\"transparent\"},L=e=>{(Array.isArray(e)?e:[e]).forEach(f)},f=e=>{let t=i.getElementById(e);t&&t.parentElement.removeChild(t)},h=(e,t)=>{let n=i.getElementById(e);if(n)n.innerHTML!==t&&(n.innerHTML=t);else{let r=i.createElement(\"style\");r.setAttribute(\"id\",e),r.innerHTML=t,i.head.appendChild(r)}},A=(e,t,n)=>{let r=i.getElementById(e);if(r)r.innerHTML!==t&&(r.innerHTML=t);else{let o=i.createElement(\"style\");o.setAttribute(\"id\",e),o.innerHTML=t;let s=`addon-backgrounds-grid${n?`-docs-${n}`:\"\"}`,a=i.getElementById(s);a?a.parentElement.insertBefore(o,a):i.head.appendChild(o)}};export{l as a,u as b,B as c,H as d,L as e,h as f,A as g};\n","import{b as a}from\"../chunk-MJNCQCOH.mjs\";import{useMemo as e,useEffect as y}from\"@storybook/addons\";import d from\"global\";var m=i=>{(Array.isArray(i)?i:[i]).forEach(s)},s=i=>{let t=d.document.getElementById(i);t&&t.parentElement&&t.parentElement.removeChild(t)},$=(i,t)=>{let n=d.document.getElementById(i);if(n)n.innerHTML!==t&&(n.innerHTML=t);else{let o=d.document.createElement(\"style\");o.setAttribute(\"id\",i),o.innerHTML=t,d.document.head.appendChild(o)}};import{dedent as b}from\"ts-dedent\";function u(i){return b`\n    ${i} body {\n      outline: 1px solid #2980b9 !important;\n    }\n\n    ${i} article {\n      outline: 1px solid #3498db !important;\n    }\n\n    ${i} nav {\n      outline: 1px solid #0088c3 !important;\n    }\n\n    ${i} aside {\n      outline: 1px solid #33a0ce !important;\n    }\n\n    ${i} section {\n      outline: 1px solid #66b8da !important;\n    }\n\n    ${i} header {\n      outline: 1px solid #99cfe7 !important;\n    }\n\n    ${i} footer {\n      outline: 1px solid #cce7f3 !important;\n    }\n\n    ${i} h1 {\n      outline: 1px solid #162544 !important;\n    }\n\n    ${i} h2 {\n      outline: 1px solid #314e6e !important;\n    }\n\n    ${i} h3 {\n      outline: 1px solid #3e5e85 !important;\n    }\n\n    ${i} h4 {\n      outline: 1px solid #449baf !important;\n    }\n\n    ${i} h5 {\n      outline: 1px solid #c7d1cb !important;\n    }\n\n    ${i} h6 {\n      outline: 1px solid #4371d0 !important;\n    }\n\n    ${i} main {\n      outline: 1px solid #2f4f90 !important;\n    }\n\n    ${i} address {\n      outline: 1px solid #1a2c51 !important;\n    }\n\n    ${i} div {\n      outline: 1px solid #036cdb !important;\n    }\n\n    ${i} p {\n      outline: 1px solid #ac050b !important;\n    }\n\n    ${i} hr {\n      outline: 1px solid #ff063f !important;\n    }\n\n    ${i} pre {\n      outline: 1px solid #850440 !important;\n    }\n\n    ${i} blockquote {\n      outline: 1px solid #f1b8e7 !important;\n    }\n\n    ${i} ol {\n      outline: 1px solid #ff050c !important;\n    }\n\n    ${i} ul {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${i} li {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${i} dl {\n      outline: 1px solid #fd3427 !important;\n    }\n\n    ${i} dt {\n      outline: 1px solid #ff0043 !important;\n    }\n\n    ${i} dd {\n      outline: 1px solid #e80174 !important;\n    }\n\n    ${i} figure {\n      outline: 1px solid #ff00bb !important;\n    }\n\n    ${i} figcaption {\n      outline: 1px solid #bf0032 !important;\n    }\n\n    ${i} table {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${i} caption {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${i} thead {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${i} tbody {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${i} tfoot {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${i} tr {\n      outline: 1px solid #86c0b2 !important;\n    }\n\n    ${i} th {\n      outline: 1px solid #a1e7d6 !important;\n    }\n\n    ${i} td {\n      outline: 1px solid #3f5a54 !important;\n    }\n\n    ${i} col {\n      outline: 1px solid #6c9a8f !important;\n    }\n\n    ${i} colgroup {\n      outline: 1px solid #6c9a9d !important;\n    }\n\n    ${i} button {\n      outline: 1px solid #da8301 !important;\n    }\n\n    ${i} datalist {\n      outline: 1px solid #c06000 !important;\n    }\n\n    ${i} fieldset {\n      outline: 1px solid #d95100 !important;\n    }\n\n    ${i} form {\n      outline: 1px solid #d23600 !important;\n    }\n\n    ${i} input {\n      outline: 1px solid #fca600 !important;\n    }\n\n    ${i} keygen {\n      outline: 1px solid #b31e00 !important;\n    }\n\n    ${i} label {\n      outline: 1px solid #ee8900 !important;\n    }\n\n    ${i} legend {\n      outline: 1px solid #de6d00 !important;\n    }\n\n    ${i} meter {\n      outline: 1px solid #e8630c !important;\n    }\n\n    ${i} optgroup {\n      outline: 1px solid #b33600 !important;\n    }\n\n    ${i} option {\n      outline: 1px solid #ff8a00 !important;\n    }\n\n    ${i} output {\n      outline: 1px solid #ff9619 !important;\n    }\n\n    ${i} progress {\n      outline: 1px solid #e57c00 !important;\n    }\n\n    ${i} select {\n      outline: 1px solid #e26e0f !important;\n    }\n\n    ${i} textarea {\n      outline: 1px solid #cc5400 !important;\n    }\n\n    ${i} details {\n      outline: 1px solid #33848f !important;\n    }\n\n    ${i} summary {\n      outline: 1px solid #60a1a6 !important;\n    }\n\n    ${i} command {\n      outline: 1px solid #438da1 !important;\n    }\n\n    ${i} menu {\n      outline: 1px solid #449da6 !important;\n    }\n\n    ${i} del {\n      outline: 1px solid #bf0000 !important;\n    }\n\n    ${i} ins {\n      outline: 1px solid #400000 !important;\n    }\n\n    ${i} img {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${i} iframe {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${i} embed {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${i} object {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${i} param {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${i} video {\n      outline: 1px solid #6ee866 !important;\n    }\n\n    ${i} audio {\n      outline: 1px solid #027353 !important;\n    }\n\n    ${i} source {\n      outline: 1px solid #012426 !important;\n    }\n\n    ${i} canvas {\n      outline: 1px solid #a2f570 !important;\n    }\n\n    ${i} track {\n      outline: 1px solid #59a600 !important;\n    }\n\n    ${i} map {\n      outline: 1px solid #7be500 !important;\n    }\n\n    ${i} area {\n      outline: 1px solid #305900 !important;\n    }\n\n    ${i} a {\n      outline: 1px solid #ff62ab !important;\n    }\n\n    ${i} em {\n      outline: 1px solid #800b41 !important;\n    }\n\n    ${i} strong {\n      outline: 1px solid #ff1583 !important;\n    }\n\n    ${i} i {\n      outline: 1px solid #803156 !important;\n    }\n\n    ${i} b {\n      outline: 1px solid #cc1169 !important;\n    }\n\n    ${i} u {\n      outline: 1px solid #ff0430 !important;\n    }\n\n    ${i} s {\n      outline: 1px solid #f805e3 !important;\n    }\n\n    ${i} small {\n      outline: 1px solid #d107b2 !important;\n    }\n\n    ${i} abbr {\n      outline: 1px solid #4a0263 !important;\n    }\n\n    ${i} q {\n      outline: 1px solid #240018 !important;\n    }\n\n    ${i} cite {\n      outline: 1px solid #64003c !important;\n    }\n\n    ${i} dfn {\n      outline: 1px solid #b4005a !important;\n    }\n\n    ${i} sub {\n      outline: 1px solid #dba0c8 !important;\n    }\n\n    ${i} sup {\n      outline: 1px solid #cc0256 !important;\n    }\n\n    ${i} time {\n      outline: 1px solid #d6606d !important;\n    }\n\n    ${i} code {\n      outline: 1px solid #e04251 !important;\n    }\n\n    ${i} kbd {\n      outline: 1px solid #5e001f !important;\n    }\n\n    ${i} samp {\n      outline: 1px solid #9c0033 !important;\n    }\n\n    ${i} var {\n      outline: 1px solid #d90047 !important;\n    }\n\n    ${i} mark {\n      outline: 1px solid #ff0053 !important;\n    }\n\n    ${i} bdi {\n      outline: 1px solid #bf3668 !important;\n    }\n\n    ${i} bdo {\n      outline: 1px solid #6f1400 !important;\n    }\n\n    ${i} ruby {\n      outline: 1px solid #ff7b93 !important;\n    }\n\n    ${i} rt {\n      outline: 1px solid #ff2f54 !important;\n    }\n\n    ${i} rp {\n      outline: 1px solid #803e49 !important;\n    }\n\n    ${i} span {\n      outline: 1px solid #cc2643 !important;\n    }\n\n    ${i} br {\n      outline: 1px solid #db687d !important;\n    }\n\n    ${i} wbr {\n      outline: 1px solid #db175b !important;\n    }`}var f=(i,t)=>{let{globals:n}=t,o=n[a]===!0,r=t.viewMode===\"docs\",x=e(()=>{let p=r?`#anchor--${t.id} .docs-story`:\".sb-show-main\";return u(p)},[t]);return y(()=>{let p=r?`addon-outline-docs-${t.id}`:\"addon-outline\";return o?$(p,x):m(p),()=>{m(p)}},[o,x,t]),i()};var I=[f],O={[a]:!1};export{I as decorators,O as globals};\n","import a from\"util-deprecate\";import{dedent as o}from\"ts-dedent\";var h=()=>Math.random().toString(16).slice(2),r=class{constructor({transport:e,async:t=!1}={}){this.sender=h();this.events={};this.data={};this.addPeerListener=a((e,t)=>{this.addListener(e,t)},o`\n      channel.addPeerListener is deprecated\n    `);this.isAsync=t,e&&(this.transport=e,this.transport.setHandler(n=>this.handleEvent(n)))}get hasTransport(){return!!this.transport}addListener(e,t){this.events[e]=this.events[e]||[],this.events[e].push(t)}emit(e,...t){let n={type:e,args:t,from:this.sender},s={};t.length>=1&&t[0]&&t[0].options&&(s=t[0].options);let i=()=>{this.transport&&this.transport.send(n,s),this.handleEvent(n)};this.isAsync?setImmediate(i):i()}last(e){return this.data[e]}eventNames(){return Object.keys(this.events)}listenerCount(e){let t=this.listeners(e);return t?t.length:0}listeners(e){return this.events[e]||void 0}once(e,t){let n=this.onceListener(e,t);this.addListener(e,n)}removeAllListeners(e){e?this.events[e]&&delete this.events[e]:this.events={}}removeListener(e,t){let n=this.listeners(e);n&&(this.events[e]=n.filter(s=>s!==t))}on(e,t){this.addListener(e,t)}off(e,t){this.removeListener(e,t)}handleEvent(e){let t=this.listeners(e.type);t&&t.length&&t.forEach(n=>{n.apply(e,e.args)}),this.data[e.type]=e.args}onceListener(e,t){let n=(...s)=>(this.removeListener(e,n),t(...s));return n}},v=r;export{r as Channel,v as default};\n","import slash from 'slash';\nimport { dedent } from 'ts-dedent';\nimport { once } from '@storybook/client-logger'; // FIXME: types duplicated type from `core-common', to be\n// removed when we remove v6 back-compat.\n\nconst stripExtension = path => {\n  let parts = [...path];\n  const last = parts[parts.length - 1];\n  const dotIndex = last.indexOf('.');\n  const stripped = dotIndex > 0 ? last.substr(0, dotIndex) : last;\n  parts[parts.length - 1] = stripped;\n  const [first, ...rest] = parts;\n\n  if (first === '') {\n    parts = rest;\n  }\n\n  return parts;\n};\n\nconst indexRe = /^index$/i; // deal with files like \"atoms/button/{button,index}.stories.js\"\n\nconst removeRedundantFilename = paths => {\n  let prevVal;\n  return paths.filter((val, index) => {\n    if (index === paths.length - 1 && (val === prevVal || indexRe.test(val))) {\n      return false;\n    }\n\n    prevVal = val;\n    return true;\n  });\n};\n/**\n * Combines path parts together, without duplicating separators (slashes).  Used instead of `path.join`\n * because this code runs in the browser.\n *\n * @param paths array of paths to join together.\n * @returns joined path string, with single '/' between parts\n */\n\n\nfunction pathJoin(paths) {\n  const slashes = new RegExp('/{1,}', 'g');\n  return paths.join('/').replace(slashes, '/');\n}\n\nexport const userOrAutoTitleFromSpecifier = (fileName, entry, userTitle) => {\n  const {\n    directory,\n    importPathMatcher,\n    titlePrefix = ''\n  } = entry || {}; // On Windows, backslashes are used in paths, which can cause problems here\n  // slash makes sure we always handle paths with unix-style forward slash\n\n  if (typeof fileName === 'number') {\n    once.warn(dedent`\n      CSF Auto-title received a numeric fileName. This typically happens when\n      webpack is mis-configured in production mode. To force webpack to produce\n      filenames, set optimization.moduleIds = \"named\" in your webpack config.\n    `);\n  }\n\n  const normalizedFileName = slash(String(fileName));\n\n  if (importPathMatcher.exec(normalizedFileName)) {\n    if (!userTitle) {\n      const suffix = normalizedFileName.replace(directory, '');\n      const titleAndSuffix = slash(pathJoin([titlePrefix, suffix]));\n      let path = titleAndSuffix.split('/');\n      path = stripExtension(path);\n      path = removeRedundantFilename(path);\n      return path.join('/');\n    }\n\n    if (!titlePrefix) {\n      return userTitle;\n    }\n\n    return slash(pathJoin([titlePrefix, userTitle]));\n  }\n\n  return undefined;\n};\nexport const userOrAutoTitle = (fileName, storiesEntries, userTitle) => {\n  for (let i = 0; i < storiesEntries.length; i += 1) {\n    const title = userOrAutoTitleFromSpecifier(fileName, storiesEntries[i], userTitle);\n    if (title) return title;\n  }\n\n  return userTitle || undefined;\n};","const _excluded = [\"type\", \"importPath\"],\n      _excluded2 = [\"default\", \"__namedExportsOrder\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* eslint-disable no-underscore-dangle */\nimport global from 'global';\nimport { dedent } from 'ts-dedent';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport { toId, isExportStory, storyNameFromExport } from '@storybook/csf';\nimport { userOrAutoTitle, sortStoriesV6 } from '@storybook/store';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nconst docs2Warning = deprecate(() => {}, `You cannot use \\`.mdx\\` files without using \\`storyStoreV7\\`. Consider upgrading to the new store.`);\nexport class StoryStoreFacade {\n  constructor() {\n    this.projectAnnotations = void 0;\n    this.entries = void 0;\n    this.csfExports = void 0;\n    this.projectAnnotations = {\n      loaders: [],\n      decorators: [],\n      parameters: {},\n      argsEnhancers: [],\n      argTypesEnhancers: [],\n      args: {},\n      argTypes: {}\n    };\n    this.entries = {};\n    this.csfExports = {};\n  } // This doesn't actually import anything because the client-api loads fully\n  // on startup, but this is a shim after all.\n\n\n  importFn(path) {\n    return SynchronousPromise.resolve().then(() => {\n      const moduleExports = this.csfExports[path];\n      if (!moduleExports) throw new Error(`Unknown path: ${path}`);\n      return moduleExports;\n    });\n  }\n\n  getStoryIndex(store) {\n    const fileNameOrder = Object.keys(this.csfExports);\n    const storySortParameter = this.projectAnnotations.parameters?.options?.storySort;\n    const storyEntries = Object.entries(this.entries); // Add the kind parameters and global parameters to each entry\n\n    const sortableV6 = storyEntries.map(([storyId, _ref]) => {\n      let {\n        type,\n        importPath\n      } = _ref,\n          entry = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      const exports = this.csfExports[importPath];\n      const csfFile = store.processCSFFileWithCache(exports, importPath, exports.default.title);\n      let storyLike;\n\n      if (type === 'story') {\n        storyLike = store.storyFromCSFFile({\n          storyId,\n          csfFile\n        });\n      } else {\n        storyLike = Object.assign({}, entry, {\n          story: entry.name,\n          kind: entry.title,\n          componentId: toId(entry.componentId || entry.title),\n          parameters: {\n            fileName: importPath\n          }\n        });\n      }\n\n      return [storyId, storyLike, csfFile.meta.parameters, this.projectAnnotations.parameters];\n    }); // NOTE: the sortStoriesV6 version returns the v7 data format. confusing but more convenient!\n\n    let sortedV7;\n\n    try {\n      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);\n    } catch (err) {\n      if (typeof storySortParameter === 'function') {\n        throw new Error(dedent`\n          Error sorting stories with sort parameter ${storySortParameter}:\n\n          > ${err.message}\n          \n          Are you using a V7-style sort function in V6 compatibility mode?\n          \n          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n        `);\n      }\n\n      throw err;\n    }\n\n    const entries = sortedV7.reduce((acc, s) => {\n      // We use the original entry we stored in `this.stories` because it is possible that the CSF file itself\n      // exports a `parameters.fileName` which can be different and mess up our `importFn`.\n      // In fact, in Storyshots there is a Jest transformer that does exactly that.\n      // NOTE: this doesn't actually change the story object, just the index.\n      acc[s.id] = this.entries[s.id];\n      return acc;\n    }, {});\n    return {\n      v: 4,\n      entries\n    };\n  }\n\n  clearFilenameExports(fileName) {\n    if (!this.csfExports[fileName]) {\n      return;\n    } // Clear this module's stories from the storyList and existing exports\n\n\n    Object.entries(this.entries).forEach(([id, {\n      importPath\n    }]) => {\n      if (importPath === fileName) {\n        delete this.entries[id];\n      }\n    }); // We keep this as an empty record so we can use it to maintain component order\n\n    this.csfExports[fileName] = {};\n  } // NOTE: we could potentially share some of this code with the stories.json generation\n\n\n  addStoriesFromExports(fileName, fileExports) {\n    if (fileName.match(/\\.mdx$/) && !fileName.match(/\\.stories\\.mdx$/)) {\n      docs2Warning();\n      return;\n    } // if the export haven't changed since last time we added them, this is a no-op\n\n\n    if (this.csfExports[fileName] === fileExports) {\n      return;\n    } // OTOH, if they have changed, let's clear them out first\n\n\n    this.clearFilenameExports(fileName);\n\n    const {\n      default: defaultExport,\n      __namedExportsOrder\n    } = fileExports,\n          namedExports = _objectWithoutPropertiesLoose(fileExports, _excluded2); // eslint-disable-next-line prefer-const\n\n\n    let {\n      id: componentId,\n      title\n    } = defaultExport || {};\n    const specifiers = (global.STORIES || []).map(specifier => Object.assign({}, specifier, {\n      importPathMatcher: new RegExp(specifier.importPathMatcher)\n    }));\n    title = userOrAutoTitle(fileName, specifiers, title);\n\n    if (!title) {\n      logger.info(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);\n      return;\n    }\n\n    this.csfExports[fileName] = Object.assign({}, fileExports, {\n      default: Object.assign({}, defaultExport, {\n        title\n      })\n    });\n    let sortedExports = namedExports; // prefer a user/loader provided `__namedExportsOrder` array if supplied\n    // we do this as es module exports are always ordered alphabetically\n    // see https://github.com/storybookjs/storybook/issues/9136\n\n    if (Array.isArray(__namedExportsOrder)) {\n      sortedExports = {};\n\n      __namedExportsOrder.forEach(name => {\n        const namedExport = namedExports[name];\n        if (namedExport) sortedExports[name] = namedExport;\n      });\n    }\n\n    const docsOptions = global.DOCS_OPTIONS || {};\n    const seenTitles = new Set();\n    Object.entries(sortedExports).filter(([key]) => isExportStory(key, defaultExport)).forEach(([key, storyExport]) => {\n      const exportName = storyNameFromExport(key);\n      const id = storyExport.parameters?.__id || toId(componentId || title, exportName);\n      const name = typeof storyExport !== 'function' && storyExport.name || storyExport.storyName || storyExport.story?.name || exportName;\n\n      if (!seenTitles.has(title) && docsOptions.docsPage) {\n        const name = docsOptions.defaultName;\n        const docsId = toId(componentId || title, name);\n        seenTitles.add(title);\n        this.entries[docsId] = {\n          type: 'docs',\n          standalone: false,\n          id: docsId,\n          title,\n          name,\n          importPath: fileName,\n          storiesImports: [],\n          componentId\n        };\n      }\n\n      this.entries[id] = {\n        type: 'story',\n        id,\n        name,\n        title,\n        importPath: fileName,\n        componentId\n      };\n    });\n  }\n\n}","const _excluded = [\"globals\", \"globalTypes\"],\n      _excluded2 = [\"decorators\", \"loaders\", \"component\", \"args\", \"argTypes\"],\n      _excluded3 = [\"component\", \"args\", \"argTypes\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/// <reference types=\"webpack-env\" />\nimport deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport { toId, sanitize } from '@storybook/csf';\nimport { combineParameters, composeStepRunners, normalizeInputTypes } from '@storybook/store';\nimport { StoryStoreFacade } from './StoryStoreFacade';\n// ClientApi (and StoreStore) are really singletons. However they are not created until the\n// relevant framework instanciates them via `start.js`. The good news is this happens right away.\nlet singleton;\nconst warningAlternatives = {\n  addDecorator: `Instead, use \\`export const decorators = [];\\` in your \\`preview.js\\`.`,\n  addParameters: `Instead, use \\`export const parameters = {};\\` in your \\`preview.js\\`.`,\n  addLoaders: `Instead, use \\`export const loaders = [];\\` in your \\`preview.js\\`.`\n};\n\nconst warningMessage = method => deprecate(() => {}, dedent`\n  \\`${method}\\` is deprecated, and will be removed in Storybook 7.0.\n\n  ${warningAlternatives[method]}\n\n  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`);\n\nconst warnings = {\n  addDecorator: warningMessage('addDecorator'),\n  addParameters: warningMessage('addParameters'),\n  addLoaders: warningMessage('addLoaders')\n};\n\nconst checkMethod = (method, deprecationWarning) => {\n  if (global.FEATURES?.storyStoreV7) {\n    throw new Error(dedent`You cannot use \\`${method}\\` with the new Story Store.\n\n      ${warningAlternatives[method]}`);\n  }\n\n  if (!singleton) {\n    throw new Error(`Singleton client API not yet initialized, cannot call \\`${method}\\`.`);\n  }\n\n  if (deprecationWarning) {\n    warnings[method]();\n  }\n};\n\nexport const addDecorator = (decorator, deprecationWarning = true) => {\n  checkMethod('addDecorator', deprecationWarning);\n  singleton.addDecorator(decorator);\n};\nexport const addParameters = (parameters, deprecationWarning = true) => {\n  checkMethod('addParameters', deprecationWarning);\n  singleton.addParameters(parameters);\n};\nexport const addLoader = (loader, deprecationWarning = true) => {\n  checkMethod('addLoader', deprecationWarning);\n  singleton.addLoader(loader);\n};\nexport const addArgs = args => {\n  checkMethod('addArgs', false);\n  singleton.addArgs(args);\n};\nexport const addArgTypes = argTypes => {\n  checkMethod('addArgTypes', false);\n  singleton.addArgTypes(argTypes);\n};\nexport const addArgsEnhancer = enhancer => {\n  checkMethod('addArgsEnhancer', false);\n  singleton.addArgsEnhancer(enhancer);\n};\nexport const addArgTypesEnhancer = enhancer => {\n  checkMethod('addArgTypesEnhancer', false);\n  singleton.addArgTypesEnhancer(enhancer);\n};\nexport const addStepRunner = stepRunner => {\n  checkMethod('addStepRunner', false);\n  singleton.addStepRunner(stepRunner);\n};\nexport const getGlobalRender = () => {\n  checkMethod('getGlobalRender', false);\n  return singleton.facade.projectAnnotations.render;\n};\nexport const setGlobalRender = render => {\n  checkMethod('setGlobalRender', false);\n  singleton.facade.projectAnnotations.render = render;\n};\nconst invalidStoryTypes = new Set(['string', 'number', 'boolean', 'symbol']);\nexport class ClientApi {\n  // If we don't get passed modules so don't know filenames, we can\n  // just use numeric indexes\n  constructor({\n    storyStore\n  } = {}) {\n    this.facade = void 0;\n    this.storyStore = void 0;\n    this.addons = void 0;\n    this.onImportFnChanged = void 0;\n    this.lastFileName = 0;\n    this.setAddon = deprecate(addon => {\n      this.addons = Object.assign({}, this.addons, addon);\n    }, dedent`\n      \\`setAddon\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon\n    `);\n\n    this.addDecorator = decorator => {\n      this.facade.projectAnnotations.decorators.push(decorator);\n    };\n\n    this.clearDecorators = deprecate(() => {\n      this.facade.projectAnnotations.decorators = [];\n    }, dedent`\n      \\`clearDecorators\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators\n    `);\n\n    this.addParameters = _ref => {\n      let {\n        globals,\n        globalTypes\n      } = _ref,\n          parameters = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters);\n\n      if (globals) {\n        this.facade.projectAnnotations.globals = Object.assign({}, this.facade.projectAnnotations.globals, globals);\n      }\n\n      if (globalTypes) {\n        this.facade.projectAnnotations.globalTypes = Object.assign({}, this.facade.projectAnnotations.globalTypes, normalizeInputTypes(globalTypes));\n      }\n    };\n\n    this.addStepRunner = stepRunner => {\n      this.facade.projectAnnotations.runStep = composeStepRunners([this.facade.projectAnnotations.runStep, stepRunner].filter(Boolean));\n    };\n\n    this.addLoader = loader => {\n      this.facade.projectAnnotations.loaders.push(loader);\n    };\n\n    this.addArgs = args => {\n      this.facade.projectAnnotations.args = Object.assign({}, this.facade.projectAnnotations.args, args);\n    };\n\n    this.addArgTypes = argTypes => {\n      this.facade.projectAnnotations.argTypes = Object.assign({}, this.facade.projectAnnotations.argTypes, normalizeInputTypes(argTypes));\n    };\n\n    this.addArgsEnhancer = enhancer => {\n      this.facade.projectAnnotations.argsEnhancers.push(enhancer);\n    };\n\n    this.addArgTypesEnhancer = enhancer => {\n      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);\n    };\n\n    this.storiesOf = (kind, m) => {\n      if (!kind && typeof kind !== 'string') {\n        throw new Error('Invalid or missing kind provided for stories, should be a string');\n      }\n\n      if (!m) {\n        logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`);\n      }\n\n      if (m) {\n        const proto = Object.getPrototypeOf(m);\n\n        if (proto.exports && proto.exports.default) {\n          // FIXME: throw an error in SB6.0\n          logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);\n        }\n      } // eslint-disable-next-line no-plusplus\n\n\n      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();\n      let fileName = baseFilename;\n      let i = 1; // Deal with `storiesOf()` being called twice in the same file.\n      // On HMR, `this.csfExports[fileName]` will be reset to `{}`, so an empty object is due\n      // to this export, not a second call of `storiesOf()`.\n\n      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {\n        i += 1;\n        fileName = `${baseFilename}-${i}`;\n      }\n\n      if (m && m.hot && m.hot.accept) {\n        // This module used storiesOf(), so when it re-runs on HMR, it will reload\n        // itself automatically without us needing to look at our imports\n        m.hot.accept();\n        m.hot.dispose(() => {\n          this.facade.clearFilenameExports(fileName); // We need to update the importFn as soon as the module re-evaluates\n          // (and calls storiesOf() again, etc). We could call `onImportFnChanged()`\n          // at the end of every setStories call (somehow), but then we'd need to\n          // debounce it somehow for initial startup. Instead, we'll take advantage of\n          // the fact that the evaluation of the module happens immediately in the same tick\n\n          setTimeout(() => {\n            this.onImportFnChanged?.({\n              importFn: this.importFn.bind(this)\n            });\n          }, 0);\n        });\n      }\n\n      let hasAdded = false;\n      const api = {\n        kind: kind.toString(),\n        add: () => api,\n        addDecorator: () => api,\n        addLoader: () => api,\n        addParameters: () => api\n      }; // apply addons\n\n      Object.keys(this.addons).forEach(name => {\n        const addon = this.addons[name];\n\n        api[name] = (...args) => {\n          addon.apply(api, args);\n          return api;\n        };\n      });\n      const meta = {\n        id: sanitize(kind),\n        title: kind,\n        decorators: [],\n        loaders: [],\n        parameters: {}\n      }; // We map these back to a simple default export, even though we have type guarantees at this point\n\n      this.facade.csfExports[fileName] = {\n        default: meta\n      };\n      let counter = 0;\n\n      api.add = (storyName, storyFn, parameters = {}) => {\n        hasAdded = true;\n\n        if (typeof storyName !== 'string') {\n          throw new Error(`Invalid or missing storyName provided for a \"${kind}\" story.`);\n        }\n\n        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {\n          throw new Error(`Cannot load story \"${storyName}\" in \"${kind}\" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);\n        }\n\n        const {\n          decorators,\n          loaders,\n          component,\n          args,\n          argTypes\n        } = parameters,\n              storyParameters = _objectWithoutPropertiesLoose(parameters, _excluded2); // eslint-disable-next-line no-underscore-dangle\n\n\n        const storyId = parameters.__id || toId(kind, storyName);\n        const csfExports = this.facade.csfExports[fileName]; // Whack a _ on the front incase it is \"default\"\n\n        csfExports[`story${counter}`] = {\n          name: storyName,\n          parameters: Object.assign({\n            fileName,\n            __id: storyId\n          }, storyParameters),\n          decorators,\n          loaders,\n          args,\n          argTypes,\n          component,\n          render: storyFn\n        };\n        counter += 1;\n        this.facade.entries[storyId] = {\n          id: storyId,\n          title: csfExports.default.title,\n          name: storyName,\n          importPath: fileName,\n          type: 'story'\n        };\n        return api;\n      };\n\n      api.addDecorator = decorator => {\n        if (hasAdded) throw new Error(`You cannot add a decorator after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.decorators.push(decorator);\n        return api;\n      };\n\n      api.addLoader = loader => {\n        if (hasAdded) throw new Error(`You cannot add a loader after the first story for a kind.`);\n        meta.loaders.push(loader);\n        return api;\n      };\n\n      api.addParameters = _ref2 => {\n        let {\n          component,\n          args,\n          argTypes\n        } = _ref2,\n            parameters = _objectWithoutPropertiesLoose(_ref2, _excluded3);\n\n        if (hasAdded) throw new Error(`You cannot add parameters after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.parameters = combineParameters(meta.parameters, parameters);\n        if (component) meta.component = component;\n        if (args) meta.args = Object.assign({}, meta.args, args);\n        if (argTypes) meta.argTypes = Object.assign({}, meta.argTypes, argTypes);\n        return api;\n      };\n\n      return api;\n    };\n\n    this.getStorybook = () => {\n      const {\n        entries\n      } = this.storyStore.storyIndex;\n      const kinds = {};\n      Object.entries(entries).forEach(([storyId, {\n        title,\n        name,\n        importPath,\n        type\n      }]) => {\n        if (type && type !== 'story') return;\n\n        if (!kinds[title]) {\n          kinds[title] = {\n            kind: title,\n            fileName: importPath,\n            stories: []\n          };\n        }\n\n        const {\n          storyFn\n        } = this.storyStore.fromId(storyId);\n        kinds[title].stories.push({\n          name,\n          render: storyFn\n        });\n      });\n      return Object.values(kinds);\n    };\n\n    this.raw = () => {\n      return this.storyStore.raw();\n    };\n\n    this.facade = new StoryStoreFacade();\n    this.addons = {};\n    this.storyStore = storyStore; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    singleton = this;\n  }\n\n  importFn(path) {\n    return this.facade.importFn(path);\n  }\n\n  getStoryIndex() {\n    if (!this.storyStore) {\n      throw new Error('Cannot get story index before setting storyStore');\n    }\n\n    return this.facade.getStoryIndex(this.storyStore);\n  }\n\n  // @deprecated\n  get _storyStore() {\n    return this.storyStore;\n  }\n\n}","import { dedent } from 'ts-dedent';\nimport memoize from 'memoizerific';\nconst getImportPathMap = memoize(1)(entries => Object.values(entries).reduce((acc, entry) => {\n  acc[entry.importPath] = acc[entry.importPath] || entry;\n  return acc;\n}, {}));\nexport class StoryIndexStore {\n  constructor({\n    entries\n  } = {\n    v: 4,\n    entries: {}\n  }) {\n    this.entries = void 0;\n    this.entries = entries;\n  }\n\n  entryFromSpecifier(specifier) {\n    const entries = Object.values(this.entries);\n\n    if (specifier === '*') {\n      // '*' means select the first entry. If there is none, we have no selection.\n      return entries[0];\n    }\n\n    if (typeof specifier === 'string') {\n      // Find the story with the exact id that matches the specifier (see #11571)\n      if (this.entries[specifier]) {\n        return this.entries[specifier];\n      } // Fallback to the first story that starts with the specifier\n\n\n      return entries.find(entry => entry.id.startsWith(specifier));\n    } // Try and find a story matching the name/kind, setting no selection if they don't exist.\n\n\n    const {\n      name,\n      title\n    } = specifier;\n    return entries.find(entry => entry.name === name && entry.title === title);\n  }\n\n  storyIdToEntry(storyId) {\n    const storyEntry = this.entries[storyId];\n\n    if (!storyEntry) {\n      throw new Error(dedent`Couldn't find story matching '${storyId}' after HMR.\n      - Did you remove it from your CSF file?\n      - Are you sure a story with that id exists?\n      - Please check your entries field of your main.js config.\n      - Also check the browser console and terminal for error messages.`);\n    }\n\n    return storyEntry;\n  }\n\n  importPathToEntry(importPath) {\n    return getImportPathMap(this.entries)[importPath];\n  }\n\n}","import { dequal as deepEqual } from 'dequal';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject';\nimport { dedent } from 'ts-dedent';\nconst INCOMPATIBLE = Symbol('incompatible');\n\nconst map = (arg, argType) => {\n  const type = argType.type;\n  if (arg === undefined || arg === null || !type) return arg;\n\n  if (argType.mapping) {\n    return arg;\n  }\n\n  switch (type.name) {\n    case 'string':\n      return String(arg);\n\n    case 'enum':\n      return arg;\n\n    case 'number':\n      return Number(arg);\n\n    case 'boolean':\n      return arg === 'true';\n\n    case 'array':\n      if (!type.value || !Array.isArray(arg)) return INCOMPATIBLE;\n      return arg.reduce((acc, item, index) => {\n        const mapped = map(item, {\n          type: type.value\n        });\n        if (mapped !== INCOMPATIBLE) acc[index] = mapped;\n        return acc;\n      }, new Array(arg.length));\n\n    case 'object':\n      if (typeof arg === 'string' || typeof arg === 'number') return arg;\n      if (!type.value || typeof arg !== 'object') return INCOMPATIBLE;\n      return Object.entries(arg).reduce((acc, [key, val]) => {\n        const mapped = map(val, {\n          type: type.value[key]\n        });\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n          [key]: mapped\n        });\n      }, {});\n\n    default:\n      return INCOMPATIBLE;\n  }\n};\n\nexport const mapArgsToTypes = (args, argTypes) => {\n  return Object.entries(args).reduce((acc, [key, value]) => {\n    if (!argTypes[key]) return acc;\n    const mapped = map(value, argTypes[key]);\n    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n      [key]: mapped\n    });\n  }, {});\n};\nexport const combineArgs = (value, update) => {\n  if (Array.isArray(value) && Array.isArray(update)) {\n    return update.reduce((acc, upd, index) => {\n      acc[index] = combineArgs(value[index], update[index]);\n      return acc;\n    }, [...value]).filter(v => v !== undefined);\n  }\n\n  if (!isPlainObject(value) || !isPlainObject(update)) return update;\n  return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n    if (key in update) {\n      const combined = combineArgs(value[key], update[key]);\n      if (combined !== undefined) acc[key] = combined;\n    } else {\n      acc[key] = value[key];\n    }\n\n    return acc;\n  }, {});\n};\nexport const validateOptions = (args, argTypes) => {\n  return Object.entries(argTypes).reduce((acc, [key, {\n    options\n  }]) => {\n    // Don't set args that are not defined in `args` (they can be undefined in there)\n    // see https://github.com/storybookjs/storybook/issues/15630 and\n    //   https://github.com/storybookjs/storybook/issues/17063\n    function allowArg() {\n      if (key in args) {\n        acc[key] = args[key];\n      }\n\n      return acc;\n    }\n\n    if (!options) return allowArg();\n\n    if (!Array.isArray(options)) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/react/api/argtypes\n      `);\n      return allowArg();\n    }\n\n    if (options.some(opt => opt && ['object', 'function'].includes(typeof opt))) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n      `);\n      return allowArg();\n    }\n\n    const isArray = Array.isArray(args[key]);\n    const invalidIndex = isArray && args[key].findIndex(val => !options.includes(val));\n    const isValidArray = isArray && invalidIndex === -1;\n\n    if (args[key] === undefined || options.includes(args[key]) || isValidArray) {\n      return allowArg();\n    }\n\n    const field = isArray ? `${key}[${invalidIndex}]` : key;\n    const supportedOptions = options.map(opt => typeof opt === 'string' ? `'${opt}'` : String(opt)).join(', ');\n    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);\n    return acc;\n  }, {});\n}; // TODO -- copied from router, needs to be in a shared location\n\nexport const DEEPLY_EQUAL = Symbol('Deeply equal');\nexport const deepDiff = (value, update) => {\n  if (typeof value !== typeof update) return update;\n  if (deepEqual(value, update)) return DEEPLY_EQUAL;\n\n  if (Array.isArray(value) && Array.isArray(update)) {\n    const res = update.reduce((acc, upd, index) => {\n      const diff = deepDiff(value[index], upd);\n      if (diff !== DEEPLY_EQUAL) acc[index] = diff;\n      return acc;\n    }, new Array(update.length));\n    if (update.length >= value.length) return res;\n    return res.concat(new Array(value.length - update.length).fill(undefined));\n  }\n\n  if (isPlainObject(value) && isPlainObject(update)) {\n    return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n      const diff = deepDiff(value?.[key], update?.[key]);\n      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, {\n        [key]: diff\n      });\n    }, {});\n  }\n\n  return update;\n};\nexport const NO_TARGET_NAME = '';\nexport function groupArgsByTarget({\n  args,\n  argTypes\n}) {\n  const groupedArgs = {};\n  Object.entries(args).forEach(([name, value]) => {\n    const {\n      target = NO_TARGET_NAME\n    } = argTypes[name] || {};\n    groupedArgs[target] = groupedArgs[target] || {};\n    groupedArgs[target][name] = value;\n  });\n  return groupedArgs;\n}\nexport function noTargetArgs(context) {\n  return groupArgsByTarget(context)[NO_TARGET_NAME];\n}","import deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport { deepDiff, DEEPLY_EQUAL } from './args';\nimport { getValuesFromArgTypes } from './csf/getValuesFromArgTypes';\nconst setUndeclaredWarning = deprecate(() => {}, dedent`\n    Setting a global value that is undeclared (i.e. not in the user's initial set of globals\n    or globalTypes) is deprecated and will have no effect in 7.0.\n  `);\nexport class GlobalsStore {\n  // We use ! here because TS doesn't analyse the .set() function to see if it actually get set\n  constructor({\n    globals = {},\n    globalTypes = {}\n  }) {\n    this.allowedGlobalNames = void 0;\n    this.initialGlobals = void 0;\n    this.globals = void 0;\n    this.set({\n      globals,\n      globalTypes\n    });\n  }\n\n  set({\n    globals = {},\n    globalTypes = {}\n  }) {\n    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);\n    this.allowedGlobalNames = new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    const defaultGlobals = getValuesFromArgTypes(globalTypes);\n    this.initialGlobals = Object.assign({}, defaultGlobals, globals);\n    this.globals = this.initialGlobals;\n\n    if (delta && delta !== DEEPLY_EQUAL) {\n      this.updateFromPersisted(delta);\n    }\n  }\n\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => {\n      if (this.allowedGlobalNames.has(key)) acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  updateFromPersisted(persisted) {\n    const allowedUrlGlobals = this.filterAllowedGlobals(persisted); // Note that unlike args, we do not have the same type information for globals to allow us\n    // to type check them here, so we just set them naively\n\n    this.globals = Object.assign({}, this.globals, allowedUrlGlobals);\n  }\n\n  get() {\n    return this.globals;\n  }\n\n  update(newGlobals) {\n    Object.keys(newGlobals).forEach(key => {\n      if (!this.allowedGlobalNames.has(key)) {\n        setUndeclaredWarning();\n      }\n    });\n    this.globals = Object.assign({}, this.globals, newGlobals);\n  }\n\n}","import { storyNameFromExport, toId } from '@storybook/csf';\nimport { dedent } from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nimport { normalizeInputTypes } from './normalizeInputTypes';\nconst deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nconst deprecatedStoryAnnotationWarning = deprecate(() => {}, deprecatedStoryAnnotation);\nexport function normalizeStory(key, storyAnnotations, meta) {\n  const storyObject = storyAnnotations;\n  const userStoryFn = typeof storyAnnotations === 'function' ? storyAnnotations : null;\n  const {\n    story\n  } = storyObject;\n\n  if (story) {\n    logger.debug('deprecated story', story);\n    deprecatedStoryAnnotationWarning();\n  }\n\n  const exportName = storyNameFromExport(key);\n  const name = typeof storyObject !== 'function' && storyObject.name || storyObject.storyName || story?.name || exportName;\n  const decorators = [...(storyObject.decorators || []), ...(story?.decorators || [])];\n  const parameters = Object.assign({}, story?.parameters, storyObject.parameters);\n  const args = Object.assign({}, story?.args, storyObject.args);\n  const argTypes = Object.assign({}, story?.argTypes, storyObject.argTypes);\n  const loaders = [...(storyObject.loaders || []), ...(story?.loaders || [])];\n  const {\n    render,\n    play\n  } = storyObject; // eslint-disable-next-line no-underscore-dangle\n\n  const id = parameters.__id || toId(meta.id, exportName);\n  return Object.assign({\n    moduleExport: storyAnnotations,\n    id,\n    name,\n    decorators,\n    parameters,\n    args,\n    argTypes: normalizeInputTypes(argTypes),\n    loaders\n  }, render && {\n    render\n  }, userStoryFn && {\n    userStoryFn\n  }, play && {\n    play\n  });\n}","import { dedent } from 'ts-dedent';\nimport deprecate from 'util-deprecate';\nimport global from 'global';\nimport { includeConditionalArg } from '@storybook/csf';\nimport { combineParameters } from '../parameters';\nimport { applyHooks } from '../hooks';\nimport { defaultDecorateStory } from '../decorators';\nimport { groupArgsByTarget, NO_TARGET_NAME } from '../args';\nimport { getValuesFromArgTypes } from './getValuesFromArgTypes';\nconst argTypeDefaultValueWarning = deprecate(() => {}, dedent`\n  \\`argType.defaultValue\\` is deprecated and will be removed in Storybook 7.0.\n\n  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`); // Combine all the metadata about a story (both direct and inherited from the component/global scope)\n// into a \"renderable\" story function, with all decorators applied, parameters passed as context etc\n//\n// Note that this story function is *stateless* in the sense that it does not track args or globals\n// Instead, it is expected these are tracked separately (if necessary) and are passed into each invocation.\n\nexport function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  // NOTE: in the current implementation we are doing everything once, up front, rather than doing\n  // anything at render time. The assumption is that as we don't load all the stories at once, this\n  // will have a limited cost. If this proves misguided, we can refactor it.\n  const {\n    moduleExport,\n    id,\n    name\n  } = storyAnnotations;\n  const {\n    title\n  } = componentAnnotations;\n  const parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations.parameters);\n  const decorators = [...(storyAnnotations.decorators || []), ...(componentAnnotations.decorators || []), ...(projectAnnotations.decorators || [])]; // Currently it is only possible to set these globally\n\n  const {\n    applyDecorators = defaultDecorateStory,\n    argTypesEnhancers = [],\n    argsEnhancers = [],\n    runStep\n  } = projectAnnotations;\n  const loaders = [...(projectAnnotations.loaders || []), ...(componentAnnotations.loaders || []), ...(storyAnnotations.loaders || [])]; // The render function on annotations *has* to be an `ArgsStoryFn`, so when we normalize\n  // CSFv1/2, we use a new field called `userStoryFn` so we know that it can be a LegacyStoryFn\n\n  const render = storyAnnotations.userStoryFn || storyAnnotations.render || componentAnnotations.render || projectAnnotations.render;\n  if (!render) throw new Error(`No render function available for storyId '${id}'`);\n  const passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations.argTypes);\n  const {\n    passArgsFirst = true\n  } = parameters; // eslint-disable-next-line no-underscore-dangle\n\n  parameters.__isArgsStory = passArgsFirst && render.length > 0; // Pull out args[X] into initialArgs for argTypes enhancers\n\n  const passedArgs = Object.assign({}, projectAnnotations.args, componentAnnotations.args, storyAnnotations.args);\n  const contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title,\n    kind: title,\n    // Back compat\n    id,\n    name,\n    story: name,\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer(Object.assign({}, contextForEnhancers, {\n    argTypes: accumulatedArgTypes\n  })), contextForEnhancers.argTypes); // Add argTypes[X].defaultValue to initial args (note this deprecated)\n  // We need to do this *after* the argTypesEnhancers as they may add defaultValues\n\n  const defaultArgs = getValuesFromArgTypes(contextForEnhancers.argTypes);\n\n  if (Object.keys(defaultArgs).length > 0) {\n    argTypeDefaultValueWarning();\n  }\n\n  const initialArgsBeforeEnhancers = Object.assign({}, defaultArgs, passedArgs);\n  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => Object.assign({}, accumulatedArgs, enhancer(Object.assign({}, contextForEnhancers, {\n    initialArgs: accumulatedArgs\n  }))), initialArgsBeforeEnhancers); // Add some of our metadata into parameters as we used to do this in 6.x and users may be relying on it\n\n  if (!global.FEATURES?.breakingChangesV7) {\n    contextForEnhancers.parameters = Object.assign({}, contextForEnhancers.parameters, {\n      __id: id,\n      globals: projectAnnotations.globals,\n      globalTypes: projectAnnotations.globalTypes,\n      args: contextForEnhancers.initialArgs,\n      argTypes: contextForEnhancers.argTypes\n    });\n  }\n\n  const applyLoaders = async context => {\n    const loadResults = await Promise.all(loaders.map(loader => loader(context)));\n    const loaded = Object.assign({}, ...loadResults);\n    return Object.assign({}, context, {\n      loaded\n    });\n  };\n\n  const undecoratedStoryFn = context => {\n    const mappedArgs = Object.entries(context.args).reduce((acc, [key, val]) => {\n      const mapping = context.argTypes[key]?.mapping;\n      acc[key] = mapping && val in mapping ? mapping[val] : val;\n      return acc;\n    }, {});\n    const includedArgs = Object.entries(mappedArgs).reduce((acc, [key, val]) => {\n      const argType = context.argTypes[key] || {};\n      if (includeConditionalArg(argType, mappedArgs, context.globals)) acc[key] = val;\n      return acc;\n    }, {});\n    const includedContext = Object.assign({}, context, {\n      args: includedArgs\n    });\n    const {\n      passArgsFirst: renderTimePassArgsFirst = true\n    } = context.parameters;\n    return renderTimePassArgsFirst ? render(includedContext.args, includedContext) : render(includedContext);\n  };\n\n  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);\n\n  const unboundStoryFn = context => {\n    let finalContext = context;\n\n    if (global.FEATURES?.argTypeTargetsV7) {\n      const argsByTarget = groupArgsByTarget(context);\n      finalContext = Object.assign({}, context, {\n        allArgs: context.args,\n        argsByTarget,\n        args: argsByTarget[NO_TARGET_NAME] || {}\n      });\n    }\n\n    return decoratedStoryFn(finalContext);\n  };\n\n  const {\n    play\n  } = storyAnnotations;\n\n  const playFunction = play && (async storyContext => {\n    const playFunctionContext = Object.assign({}, storyContext, {\n      step: (label, play) => // TODO: We know runStep is defined, we need a proper normalized annotations type\n      runStep(label, play, playFunctionContext)\n    });\n    return play(playFunctionContext);\n  });\n\n  return Object.freeze(Object.assign({}, contextForEnhancers, {\n    moduleExport,\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    playFunction\n  }));\n}","import mapValues from 'lodash/mapValues';\nimport { dedent } from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport { combineParameters } from './parameters';\n\nconst inferType = (value, name, visited) => {\n  const type = typeof value;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'function':\n    case 'symbol':\n      return {\n        name: type\n      };\n\n    default:\n      break;\n  }\n\n  if (value) {\n    if (visited.has(value)) {\n      logger.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        Consider using the mapping feature or fully custom args:\n        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args\n      `);\n      return {\n        name: 'other',\n        value: 'cyclic object'\n      };\n    }\n\n    visited.add(value);\n\n    if (Array.isArray(value)) {\n      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : {\n        name: 'other',\n        value: 'unknown'\n      };\n      return {\n        name: 'array',\n        value: childType\n      };\n    }\n\n    const fieldTypes = mapValues(value, field => inferType(field, name, new Set(visited)));\n    return {\n      name: 'object',\n      value: fieldTypes\n    };\n  }\n\n  return {\n    name: 'object',\n    value: {}\n  };\n};\n\nexport const inferArgTypes = context => {\n  const {\n    id,\n    argTypes: userArgTypes = {},\n    initialArgs = {}\n  } = context;\n  const argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, new Set())\n  }));\n  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n};\ninferArgTypes.secondPass = true;","import qs from 'qs';\nimport { dedent } from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject'; // Keep this in sync with validateArgs in router/src/utils.ts\n\nconst VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nconst NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nconst HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nconst COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\n\nconst validateArgs = (key = '', value) => {\n  if (key === null) return false;\n  if (key === '' || !VALIDATION_REGEXP.test(key)) return false;\n  if (value === null || value === undefined) return true; // encoded as `!null` or `!undefined`\n\n  if (value instanceof Date) return true; // encoded as modified ISO string\n\n  if (typeof value === 'number' || typeof value === 'boolean') return true;\n\n  if (typeof value === 'string') {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n\n  if (Array.isArray(value)) return value.every(v => validateArgs(key, v));\n  if (isPlainObject(value)) return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  return false;\n};\n\nconst QS_OPTIONS = {\n  delimiter: ';',\n  // we're parsing a single query param\n  allowDots: true,\n  // objects are encoded using dot notation\n  allowSparse: true,\n\n  // arrays will be merged on top of their initial value\n  decoder(str, defaultDecoder, charset, type) {\n    if (type === 'value' && str.startsWith('!')) {\n      if (str === '!undefined') return undefined;\n      if (str === '!null') return null;\n      if (str.startsWith('!date(') && str.endsWith(')')) return new Date(str.slice(6, -1));\n      if (str.startsWith('!hex(') && str.endsWith(')')) return `#${str.slice(5, -1)}`;\n      const color = str.slice(1).match(COLOR_REGEXP);\n\n      if (color) {\n        if (str.startsWith('!rgba')) return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        if (str.startsWith('!hsla')) return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        return str.startsWith('!rgb') ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n\n    if (type === 'value' && NUMBER_REGEXP.test(str)) return Number(str);\n    return defaultDecoder(str, defaultDecoder, charset);\n  }\n\n};\nexport const parseArgsParam = argsString => {\n  const parts = argsString.split(';').map(part => part.replace('=', '~').replace(':', '='));\n  return Object.entries(qs.parse(parts.join(';'), QS_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) return Object.assign(acc, {\n      [key]: value\n    });\n    once.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url\n    `);\n    return acc;\n  }, {});\n};","import global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport AnsiToHtml from 'ansi-to-html';\nimport { dedent } from 'ts-dedent';\nimport qs from 'qs';\nconst {\n  document\n} = global;\nconst PREPARING_DELAY = 100;\nconst layoutClassMap = {\n  centered: 'sb-main-centered',\n  fullscreen: 'sb-main-fullscreen',\n  padded: 'sb-main-padded'\n};\nvar Mode;\n\n(function (Mode) {\n  Mode[\"MAIN\"] = \"MAIN\";\n  Mode[\"NOPREVIEW\"] = \"NOPREVIEW\";\n  Mode[\"PREPARING_STORY\"] = \"PREPARING_STORY\";\n  Mode[\"PREPARING_DOCS\"] = \"PREPARING_DOCS\";\n  Mode[\"ERROR\"] = \"ERROR\";\n})(Mode || (Mode = {}));\n\nconst classes = {\n  PREPARING_STORY: 'sb-show-preparing-story',\n  PREPARING_DOCS: 'sb-show-preparing-docs',\n  MAIN: 'sb-show-main',\n  NOPREVIEW: 'sb-show-nopreview',\n  ERROR: 'sb-show-errordisplay'\n};\nconst ansiConverter = new AnsiToHtml({\n  escapeXML: true\n});\nexport class WebView {\n  constructor() {\n    this.currentLayoutClass = void 0;\n    this.testing = false;\n    this.preparingTimeout = void 0;\n    // Special code for testing situations\n    const {\n      __SPECIAL_TEST_PARAMETER__\n    } = qs.parse(document.location.search, {\n      ignoreQueryPrefix: true\n    });\n\n    switch (__SPECIAL_TEST_PARAMETER__) {\n      case 'preparing-story':\n        {\n          this.showPreparingStory();\n          this.testing = true;\n          break;\n        }\n\n      case 'preparing-docs':\n        {\n          this.showPreparingDocs();\n          this.testing = true;\n          break;\n        }\n\n      default: // pass;\n\n    }\n  } // Get ready to render a story, returning the element to render to\n\n\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document.documentElement.scrollTop = 0;\n    document.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n\n  storyRoot() {\n    return document.getElementById('storybook-root');\n  }\n\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout('fullscreen');\n    return this.docsRoot();\n  }\n\n  docsRoot() {\n    return document.getElementById('storybook-docs');\n  }\n\n  applyLayout(layout = 'padded') {\n    if (layout === 'none') {\n      document.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document.body.classList.remove(this.currentLayoutClass);\n    document.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger.warn(dedent`The desired layout: ${layout} is not a valid option.\n         The possible options are: ${Object.keys(layoutClassMap).join(', ')}, none.`);\n    }\n  }\n\n  showMode(mode) {\n    clearTimeout(this.preparingTimeout);\n    Object.keys(Mode).forEach(otherMode => {\n      if (otherMode === mode) {\n        document.body.classList.add(classes[otherMode]);\n      } else {\n        document.body.classList.remove(classes[otherMode]);\n      }\n    });\n  }\n\n  showErrorDisplay({\n    message = '',\n    stack = ''\n  }) {\n    let header = message;\n    let detail = stack;\n    const parts = message.split('\\n');\n\n    if (parts.length > 1) {\n      [header] = parts;\n      detail = parts.slice(1).join('\\n');\n    }\n\n    document.getElementById('error-message').innerHTML = ansiConverter.toHtml(header);\n    document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(detail);\n    this.showMode(Mode.ERROR);\n  }\n\n  showNoPreview() {\n    if (this.testing) return;\n    this.showMode(Mode.NOPREVIEW); // In storyshots this can get called and these two can be null\n\n    this.storyRoot()?.setAttribute('hidden', 'true');\n    this.docsRoot()?.setAttribute('hidden', 'true');\n  }\n\n  showPreparingStory({\n    immediate = false\n  } = {}) {\n    clearTimeout(this.preparingTimeout);\n\n    if (immediate) {\n      this.showMode(Mode.PREPARING_STORY);\n    } else {\n      this.preparingTimeout = setTimeout(() => this.showMode(Mode.PREPARING_STORY), PREPARING_DELAY);\n    }\n  }\n\n  showPreparingDocs() {\n    clearTimeout(this.preparingTimeout);\n    this.preparingTimeout = setTimeout(() => this.showMode(Mode.PREPARING_DOCS), PREPARING_DELAY);\n  }\n\n  showMain() {\n    this.showMode(Mode.MAIN);\n  }\n\n  showDocs() {\n    this.storyRoot().setAttribute('hidden', 'true');\n    this.docsRoot().removeAttribute('hidden');\n  }\n\n  showStory() {\n    this.docsRoot().setAttribute('hidden', 'true');\n    this.storyRoot().removeAttribute('hidden');\n  }\n\n  showStoryDuringRender() {\n    // When 'showStory' is called (at the start of rendering) we get rid of our display:none\n    // from all children of the root (but keep the preparing spinner visible). This may mean\n    // that very weird and high z-index stories are briefly visible.\n    // See https://github.com/storybookjs/storybook/issues/16847 and\n    //   http://localhost:9011/?path=/story/core-rendering--auto-focus (official SB)\n    document.body.classList.add(classes.MAIN);\n  }\n\n}","import { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport { CONFIG_ERROR, FORCE_REMOUNT, FORCE_RE_RENDER, GLOBALS_UPDATED, RESET_STORY_ARGS, SET_GLOBALS, STORY_ARGS_UPDATED, STORY_INDEX_INVALIDATED, UPDATE_GLOBALS, UPDATE_STORY_ARGS } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { addons } from '@storybook/addons';\nimport { StoryStore } from '@storybook/store';\nimport { StoryRender } from './render/StoryRender';\nconst {\n  fetch\n} = global;\nconst STORY_INDEX_PATH = './index.json';\nexport class Preview {\n  constructor(channel = addons.getChannel()) {\n    this.channel = channel;\n    this.serverChannel = void 0;\n    this.storyStore = void 0;\n    this.getStoryIndex = void 0;\n    this.importFn = void 0;\n    this.renderToDOM = void 0;\n    this.storyRenders = [];\n    this.previewEntryError = void 0;\n\n    if (global.FEATURES?.storyStoreV7 && addons.hasServerChannel()) {\n      this.serverChannel = addons.getServerChannel();\n    }\n\n    this.storyStore = new StoryStore();\n  } // INITIALIZATION\n  // NOTE: the reason that the preview and store's initialization code is written in a promise\n  // style and not `async-await`, and the use of `SynchronousPromise`s is in order to allow\n  // storyshots to immediately call `raw()` on the store without waiting for a later tick.\n  // (Even simple things like `Promise.resolve()` and `await` involve the callback happening\n  // in the next promise \"tick\").\n  // See the comment in `storyshots-core/src/api/index.ts` for more detail.\n\n\n  initialize({\n    getStoryIndex,\n    importFn,\n    getProjectAnnotations\n  }) {\n    // We save these two on initialization in case `getProjectAnnotations` errors,\n    // in which case we may need them later when we recover.\n    this.getStoryIndex = getStoryIndex;\n    this.importFn = importFn;\n    this.setupListeners();\n    return this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then(projectAnnotations => this.initializeWithProjectAnnotations(projectAnnotations));\n  }\n\n  setupListeners() {\n    this.serverChannel?.on(STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));\n    this.channel.on(UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));\n    this.channel.on(UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));\n    this.channel.on(RESET_STORY_ARGS, this.onResetArgs.bind(this));\n    this.channel.on(FORCE_RE_RENDER, this.onForceReRender.bind(this));\n    this.channel.on(FORCE_REMOUNT, this.onForceRemount.bind(this));\n  }\n\n  getProjectAnnotationsOrRenderError(getProjectAnnotations) {\n    return SynchronousPromise.resolve().then(getProjectAnnotations).then(projectAnnotations => {\n      this.renderToDOM = projectAnnotations.renderToDOM;\n\n      if (!this.renderToDOM) {\n        throw new Error(dedent`\n            Expected your framework's preset to export a \\`renderToDOM\\` field.\n\n            Perhaps it needs to be upgraded for Storybook 6.4?\n\n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field\n          `);\n      }\n\n      return projectAnnotations;\n    }).catch(err => {\n      // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and\n      // needs to be show to the user as a simple error\n      this.renderPreviewEntryError('Error reading preview.js:', err);\n      throw err;\n    });\n  } // If initialization gets as far as project annotations, this function runs.\n\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.setInitialGlobals();\n    let storyIndexPromise;\n\n    if (global.FEATURES?.storyStoreV7) {\n      storyIndexPromise = this.getStoryIndexFromServer();\n    } else {\n      if (!this.getStoryIndex) {\n        throw new Error('No `getStoryIndex` passed defined in v6 mode');\n      }\n\n      storyIndexPromise = SynchronousPromise.resolve().then(this.getStoryIndex);\n    }\n\n    return storyIndexPromise.then(storyIndex => this.initializeWithStoryIndex(storyIndex)).catch(err => {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    });\n  }\n\n  async setInitialGlobals() {\n    this.emitGlobals();\n  }\n\n  emitGlobals() {\n    if (!this.storyStore.globals || !this.storyStore.projectAnnotations) throw new Error(`Cannot emit before initialization`);\n    this.channel.emit(SET_GLOBALS, {\n      globals: this.storyStore.globals.get() || {},\n      globalTypes: this.storyStore.projectAnnotations.globalTypes || {}\n    });\n  }\n\n  async getStoryIndexFromServer() {\n    const result = await fetch(STORY_INDEX_PATH);\n    if (result.status === 200) return result.json();\n    throw new Error(await result.text());\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    if (!this.importFn) throw new Error(`Cannot call initializeWithStoryIndex before initialization`);\n    return this.storyStore.initialize({\n      storyIndex,\n      importFn: this.importFn,\n      cache: !global.FEATURES?.storyStoreV7\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    delete this.previewEntryError;\n    const projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);\n\n    if (!this.storyStore.projectAnnotations) {\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      return;\n    }\n\n    await this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.emitGlobals();\n  }\n\n  async onStoryIndexChanged() {\n    delete this.previewEntryError;\n\n    if (!this.storyStore.projectAnnotations) {\n      // We haven't successfully set project annotations yet,\n      // we need to do that before we can do anything else.\n      return;\n    }\n\n    try {\n      const storyIndex = await this.getStoryIndexFromServer(); // This is the first time the story index worked, let's load it into the store\n\n      if (!this.storyStore.storyIndex) {\n        await this.initializeWithStoryIndex(storyIndex);\n      } // Update the store with the new stories.\n\n\n      await this.onStoriesChanged({\n        storyIndex\n      });\n    } catch (err) {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    }\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await this.storyStore.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n  }\n\n  async onUpdateGlobals({\n    globals\n  }) {\n    if (!this.storyStore.globals) throw new Error(`Cannot call onUpdateGlobals before initialization`);\n    this.storyStore.globals.update(globals);\n    await Promise.all(this.storyRenders.map(r => r.rerender()));\n    this.channel.emit(GLOBALS_UPDATED, {\n      globals: this.storyStore.globals.get(),\n      initialGlobals: this.storyStore.globals.initialGlobals\n    });\n  }\n\n  async onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    this.storyStore.args.update(storyId, updatedArgs);\n    await Promise.all(this.storyRenders.filter(r => r.id === storyId).map(r => r.rerender()));\n    this.channel.emit(STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStore.args.get(storyId)\n    });\n  }\n\n  async onResetArgs({\n    storyId,\n    argNames\n  }) {\n    // NOTE: we have to be careful here and avoid await-ing when updating a rendered's args.\n    // That's because below in `renderStoryToElement` we have also bound to this event and will\n    // render the story in the same tick.\n    // However, we can do that safely as the current story is available in `this.storyRenders`\n    const render = this.storyRenders.find(r => r.id === storyId);\n    const story = render?.story || (await this.storyStore.loadStory({\n      storyId\n    }));\n    const argNamesToReset = argNames || [...new Set([...Object.keys(story.initialArgs), ...Object.keys(this.storyStore.args.get(storyId))])];\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = story.initialArgs[argName];\n      return acc;\n    }, {});\n    await this.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  } // ForceReRender does not include a story id, so we simply must\n  // re-render all stories in case they are relevant\n\n\n  async onForceReRender() {\n    await Promise.all(this.storyRenders.map(r => r.rerender()));\n  }\n\n  async onForceRemount({\n    storyId\n  }) {\n    await Promise.all(this.storyRenders.filter(r => r.id === storyId).map(r => r.remount()));\n  } // Used by docs' modernInlineRender to render a story to a given element\n  // Note this short-circuits the `prepare()` phase of the StoryRender,\n  // main to be consistent with the previous behaviour. In the future,\n  // we will change it to go ahead and load the story, which will end up being\n  // \"instant\", although async.\n\n\n  renderStoryToElement(story, element) {\n    if (!this.renderToDOM) throw new Error(`Cannot call renderStoryToElement before initialization`);\n    const render = new StoryRender(this.channel, this.storyStore, this.renderToDOM, this.inlineStoryCallbacks(story.id), story.id, 'docs', story);\n    render.renderToElement(element);\n    this.storyRenders.push(render);\n    return async () => {\n      await this.teardownRender(render);\n    };\n  }\n\n  async teardownRender(render, {\n    viewModeChanged\n  } = {}) {\n    this.storyRenders = this.storyRenders.filter(r => r !== render);\n    await render?.teardown?.({\n      viewModeChanged\n    });\n  } // API\n\n\n  async extract(options) {\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n\n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if (global.FEATURES?.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  inlineStoryCallbacks(storyId) {\n    return {\n      showMain: () => {},\n      showError: err => logger.error(`Error rendering docs story (${storyId})`, err),\n      showException: err => logger.error(`Error rendering docs story (${storyId})`, err)\n    };\n  }\n\n  renderPreviewEntryError(reason, err) {\n    this.previewEntryError = err;\n    logger.error(reason);\n    logger.error(err);\n    this.channel.emit(CONFIG_ERROR, err);\n  }\n\n}","import deprecate from 'util-deprecate';\nimport { dedent } from 'ts-dedent';\nimport global from 'global';\nimport { CURRENT_STORY_WAS_SET, IGNORED_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_KEYDOWN, SET_CURRENT_STORY, SET_STORIES, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_QUERY_PARAMS } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { Preview } from './Preview';\nimport { UrlStore } from './UrlStore';\nimport { WebView } from './WebView';\nimport { PREPARE_ABORTED, StoryRender } from './render/StoryRender';\nimport { TemplateDocsRender } from './render/TemplateDocsRender';\nimport { StandaloneDocsRender } from './render/StandaloneDocsRender';\nconst {\n  window: globalWindow\n} = global;\n\nfunction focusInInput(event) {\n  const target = event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;\n}\n\nfunction isStoryRender(r) {\n  return r.type === 'story';\n}\n\nexport class PreviewWeb extends Preview {\n  constructor() {\n    super();\n    this.urlStore = void 0;\n    this.view = void 0;\n    this.previewEntryError = void 0;\n    this.currentSelection = void 0;\n    this.currentRender = void 0;\n    this.view = new WebView();\n    this.urlStore = new UrlStore(); // Add deprecated APIs for back-compat\n    // @ts-ignore\n\n    this.storyStore.getSelection = deprecate(() => this.urlStore.selection, dedent`\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n\n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      `);\n  }\n\n  setupListeners() {\n    super.setupListeners();\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    this.channel.on(SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));\n    this.channel.on(PRELOAD_ENTRIES, this.onPreloadStories.bind(this));\n  }\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    return super.initializeWithProjectAnnotations(projectAnnotations).then(() => this.setInitialGlobals());\n  }\n\n  async setInitialGlobals() {\n    if (!this.storyStore.globals) throw new Error(`Cannot call setInitialGlobals before initialization`);\n    const {\n      globals\n    } = this.urlStore.selectionSpecifier || {};\n\n    if (globals) {\n      this.storyStore.globals.updateFromPersisted(globals);\n    }\n\n    this.emitGlobals();\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    return super.initializeWithStoryIndex(storyIndex).then(() => {\n      if (!global.FEATURES?.storyStoreV7) {\n        this.channel.emit(SET_STORIES, this.storyStore.getSetStoriesPayload());\n      }\n\n      return this.selectSpecifiedStory();\n    });\n  } // Use the selection specifier to choose a story, then render it\n\n\n  async selectSpecifiedStory() {\n    if (!this.storyStore.storyIndex) throw new Error(`Cannot call selectSpecifiedStory before initialization`);\n\n    if (!this.urlStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n\n    const {\n      storySpecifier,\n      args\n    } = this.urlStore.selectionSpecifier;\n    const entry = this.storyStore.storyIndex.entryFromSpecifier(storySpecifier);\n\n    if (!entry) {\n      if (storySpecifier === '*') {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find any stories in your Storybook.\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      } else {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find story matching '${storySpecifier}'.\n            - Are you sure a story with that id exists?\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      }\n\n      return;\n    }\n\n    const {\n      id: storyId,\n      type: viewMode\n    } = entry;\n    this.urlStore.setSelection({\n      storyId,\n      viewMode\n    });\n    this.channel.emit(STORY_SPECIFIED, this.urlStore.selection);\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    await this.renderSelection({\n      persistedArgs: args\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    await super.onGetProjectAnnotationsChanged({\n      getProjectAnnotations\n    });\n    this.renderSelection();\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    super.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n\n    if (!global.FEATURES?.storyStoreV7) {\n      this.channel.emit(SET_STORIES, await this.storyStore.getSetStoriesPayload());\n    }\n\n    if (this.urlStore.selection) {\n      await this.renderSelection();\n    } else {\n      // Our selection has never applied before, but maybe it does now, let's try!\n      await this.selectSpecifiedStory();\n    }\n  }\n\n  onKeydown(event) {\n    if (!this.currentRender?.disableKeyListeners && !focusInInput(event)) {\n      // We have to pick off the keys of the event that we need on the other side\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey,\n        key,\n        code,\n        keyCode\n      } = event;\n      this.channel.emit(PREVIEW_KEYDOWN, {\n        event: {\n          altKey,\n          ctrlKey,\n          metaKey,\n          shiftKey,\n          key,\n          code,\n          keyCode\n        }\n      });\n    }\n  }\n\n  onSetCurrentStory(selection) {\n    this.urlStore.setSelection(Object.assign({\n      viewMode: 'story'\n    }, selection));\n    this.channel.emit(CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    this.renderSelection();\n  }\n\n  onUpdateQueryParams(queryParams) {\n    this.urlStore.setQueryParams(queryParams);\n  }\n\n  async onUpdateGlobals({\n    globals\n  }) {\n    super.onUpdateGlobals({\n      globals\n    });\n\n    if (this.currentRender instanceof StandaloneDocsRender || this.currentRender instanceof TemplateDocsRender) {\n      await this.currentRender.rerender?.();\n    }\n  }\n\n  async onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    super.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  }\n\n  async onPreloadStories({\n    ids\n  }) {\n    /**\n     * It's possible that we're trying to preload a story in a ref we haven't loaded the iframe for yet.\n     * Because of the way the targeting works, if we can't find the targeted iframe,\n     * we'll use the currently active iframe which can cause the event to be targeted\n     * to the wrong iframe, causing an error if the storyId does not exists there.\n     */\n    await Promise.allSettled(ids.map(id => this.storyStore.loadEntry(id)));\n  } // RENDERING\n  // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n\n\n  async renderSelection({\n    persistedArgs\n  } = {}) {\n    const {\n      renderToDOM\n    } = this;\n    if (!renderToDOM) throw new Error('Cannot call renderSelection before initialization');\n    const {\n      selection\n    } = this.urlStore;\n    if (!selection) throw new Error('Cannot call renderSelection as no selection was made');\n    const {\n      storyId\n    } = selection;\n    let entry;\n\n    try {\n      entry = await this.storyStore.storyIdToEntry(storyId);\n    } catch (err) {\n      if (this.currentRender) await this.teardownRender(this.currentRender);\n      this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n\n    const storyIdChanged = this.currentSelection?.storyId !== storyId;\n    const viewModeChanged = this.currentRender?.type !== entry.type; // Show a spinner while we load the next story\n\n    if (entry.type === 'story') {\n      this.view.showPreparingStory({\n        immediate: viewModeChanged\n      });\n    } else {\n      this.view.showPreparingDocs();\n    } // If the last render is still preparing, let's drop it right now. Either\n    //   (a) it is a different story, which means we would drop it later, OR\n    //   (b) it is the *same* story, in which case we will resolve our own .prepare() at the\n    //       same moment anyway, and we should just \"take over\" the rendering.\n    // (We can't tell which it is yet, because it is possible that an HMR is going on and\n    //  even though the storyId is the same, the story itself is not).\n\n\n    if (this.currentRender?.isPreparing()) {\n      await this.teardownRender(this.currentRender);\n    }\n\n    let render;\n\n    if (entry.type === 'story') {\n      render = new StoryRender(this.channel, this.storyStore, (...args) => {\n        // At the start of renderToDOM we make the story visible (see note in WebView)\n        this.view.showStoryDuringRender();\n        return renderToDOM(...args);\n      }, this.mainStoryCallbacks(storyId), storyId, 'story');\n    } else if (entry.standalone) {\n      render = new StandaloneDocsRender(this.channel, this.storyStore, entry);\n    } else {\n      render = new TemplateDocsRender(this.channel, this.storyStore, entry);\n    } // We need to store this right away, so if the story changes during\n    // the async `.prepare()` below, we can (potentially) cancel it\n\n\n    const lastSelection = this.currentSelection;\n    this.currentSelection = selection;\n    const lastRender = this.currentRender;\n    this.currentRender = render;\n\n    try {\n      await render.prepare();\n    } catch (err) {\n      if (err !== PREPARE_ABORTED) {\n        // We are about to render an error so make sure the previous story is\n        // no longer rendered.\n        if (lastRender) await this.teardownRender(lastRender);\n        this.renderStoryLoadingException(storyId, err);\n      }\n\n      return;\n    }\n\n    const implementationChanged = !storyIdChanged && lastRender && !render.isEqual(lastRender);\n\n    if (persistedArgs && isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      this.storyStore.args.updateFromPersisted(render.story, persistedArgs);\n    } // Don't re-render the story if nothing has changed to justify it\n\n\n    if (lastRender && !lastRender.torndown && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.currentRender = lastRender;\n      this.channel.emit(STORY_UNCHANGED, storyId);\n      this.view.showMain();\n      return;\n    } // Wait for the previous render to leave the page. NOTE: this will wait to ensure anything async\n    // is properly aborted, which (in some cases) can lead to the whole screen being refreshed.\n\n\n    if (lastRender) await this.teardownRender(lastRender, {\n      viewModeChanged\n    }); // If we are rendering something new (as opposed to re-rendering the same or first story), emit\n\n    if (lastSelection && (storyIdChanged || viewModeChanged)) {\n      this.channel.emit(STORY_CHANGED, storyId);\n    }\n\n    if (isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      const {\n        parameters,\n        initialArgs,\n        argTypes,\n        args\n      } = this.storyStore.getStoryContext(render.story);\n\n      if (global.FEATURES?.storyStoreV7) {\n        this.channel.emit(STORY_PREPARED, {\n          id: storyId,\n          parameters,\n          initialArgs,\n          argTypes,\n          args\n        });\n      } // For v6 mode / compatibility\n      // If the implementation changed, or args were persisted, the args may have changed,\n      // and the STORY_PREPARED event above may not be respected.\n\n\n      if (implementationChanged || persistedArgs) {\n        this.channel.emit(STORY_ARGS_UPDATED, {\n          storyId,\n          args\n        });\n      }\n    }\n\n    if (isStoryRender(render)) {\n      if (!render.story) throw new Error('Render has not been prepared!');\n      this.storyRenders.push(render);\n      this.currentRender.renderToElement(this.view.prepareForStory(render.story));\n    } else {\n      this.currentRender.renderToElement(this.view.prepareForDocs(), this.renderStoryToElement.bind(this));\n    }\n  }\n\n  async teardownRender(render, {\n    viewModeChanged = false\n  } = {}) {\n    this.storyRenders = this.storyRenders.filter(r => r !== render);\n    await render?.teardown?.({\n      viewModeChanged\n    });\n  } // API\n\n\n  async extract(options) {\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n\n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if (global.FEATURES?.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  mainStoryCallbacks(storyId) {\n    return {\n      showMain: () => this.view.showMain(),\n      showError: err => this.renderError(storyId, err),\n      showException: err => this.renderException(storyId, err)\n    };\n  }\n\n  inlineStoryCallbacks(storyId) {\n    return {\n      showMain: () => {},\n      showError: err => logger.error(`Error rendering docs story (${storyId})`, err),\n      showException: err => logger.error(`Error rendering docs story (${storyId})`, err)\n    };\n  }\n\n  renderPreviewEntryError(reason, err) {\n    super.renderPreviewEntryError(reason, err);\n    this.view.showErrorDisplay(err);\n  }\n\n  renderMissingStory() {\n    this.view.showNoPreview();\n    this.channel.emit(STORY_MISSING);\n  }\n\n  renderStoryLoadingException(storySpecifier, err) {\n    logger.error(`Unable to load story '${storySpecifier}':`);\n    logger.error(err);\n    this.view.showErrorDisplay(err);\n    this.channel.emit(STORY_MISSING, storySpecifier);\n  } // renderException is used if we fail to render the story and it is uncaught by the app layer\n\n\n  renderException(storyId, error) {\n    const {\n      name = 'Error',\n      message = String(error),\n      stack\n    } = error;\n    this.channel.emit(STORY_THREW_EXCEPTION, {\n      name,\n      message,\n      stack\n    });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.\n\n    if (error !== IGNORED_EXCEPTION) {\n      this.view.showErrorDisplay(error);\n      logger.error(`Error rendering story '${storyId}':`);\n      logger.error(error);\n    }\n  } // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n\n\n  renderError(storyId, {\n    title,\n    description\n  }) {\n    logger.error(`Error rendering story ${title}: ${description}`);\n    this.channel.emit(STORY_ERRORED, {\n      title,\n      description\n    });\n    this.channel.emit(STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    });\n    this.view.showErrorDisplay({\n      message: title,\n      stack: description\n    });\n  }\n\n}","import{a as ke,b as Le}from\"./chunk-X53CQCCB.mjs\";import{extractComponentDescription as $t,enhanceArgTypes as Yt}from\"@storybook/docs-tools\";import Re from\"prop-types\";import{hasDocgen as At,extractComponentProps as St,TypeSystem as Ce}from\"@storybook/docs-tools\";import{createSummaryValue as D,isTooLongForTypeSummary as tt}from\"@storybook/docs-tools\";function G(e,t){let r=e!=null,n=t!=null;if(!r&&!n)return\"\";let o=[];if(r){let s=e.map(a=>{let c=a.getPrettyName(),i=a.getTypeName();return i!=null?`${c}: ${i}`:c});o.push(`(${s.join(\", \")})`)}else o.push(\"()\");return n&&o.push(`=> ${t.getTypeName()}`),o.join(\" \")}function z(e,t){let r=e!=null,n=t!=null;if(!r&&!n)return\"\";let o=[];return r?o.push(\"( ... )\"):o.push(\"()\"),n&&o.push(`=> ${t.getTypeName()}`),o.join(\" \")}function Q(e){return e.replace(/,/g,`,\\r\n`)}var S=\"custom\",d=\"object\",h=\"array\",Z=\"class\",f=\"func\",m=\"element\";import Me from\"html-tags\";function E(e){return Me.includes(e.toLowerCase())}import{generate as Ve}from\"escodegen\";import{dedent as Ue}from\"ts-dedent\";var ee={format:{indent:{style:\"  \"},semicolons:!1}},_e={...ee,format:{newline:\"\"}},ve={...ee};function y(e,t=!1){return Ve(e,t?_e:ve)}function R(e,t=!1){return t?we(e):y(e)}function we(e){let t=y(e,!0);return t.endsWith(\" }\")||(t=`${t.slice(0,-1)} }`),t}function _(e,t=!1){return t?$e(e):Be(e)}function Be(e){let t=y(e);return t.endsWith(\"  }]\")&&(t=Ue(t)),t}function $e(e){let t=y(e,!0);return t.startsWith(\"[    \")&&(t=t.replace(\"[    \",\"[\")),t}var F=e=>e.$$typeof===Symbol.for(\"react.memo\"),te=e=>e.$$typeof===Symbol.for(\"react.forward_ref\");import{Parser as Ye}from\"acorn\";import Xe from\"acorn-jsx\";import*as I from\"acorn-walk\";var v={...I.base,JSXElement:()=>{}},We=Ye.extend(Xe());function C(e){return e!=null?e.name:null}function re(e){return e.filter(t=>t.type===\"ObjectExpression\"||t.type===\"ArrayExpression\")}function ne(e){let t=[];return I.ancestor(e,{ObjectExpression(r,n){t.push(re(n).length)},ArrayExpression(r,n){t.push(re(n).length)}},v),Math.max(...t)}function He(e){return{inferredType:{type:\"Identifier\",identifier:C(e)},ast:e}}function qe(e){return{inferredType:{type:\"Literal\"},ast:e}}function Ke(e){let t;I.simple(e.body,{JSXElement(s){t=s}},v);let n={type:t!=null?\"Element\":\"Function\",params:e.params,hasParams:e.params.length!==0},o=C(e.id);return o!=null&&(n.identifier=o),{inferredType:n,ast:e}}function Ge(e){let t;return I.simple(e.body,{JSXElement(n){t=n}},v),{inferredType:{type:t!=null?\"Element\":\"Class\",identifier:C(e.id)},ast:e}}function ze(e){let t={type:\"Element\"},r=C(e.openingElement.name);return r!=null&&(t.identifier=r),{inferredType:t,ast:e}}function Qe(e){let t=e.callee.type===\"MemberExpression\"?e.callee.property:e.callee;return C(t)===\"shape\"?oe(e.arguments[0]):null}function oe(e){return{inferredType:{type:\"Object\",depth:ne(e)},ast:e}}function Ze(e){return{inferredType:{type:\"Array\",depth:ne(e)},ast:e}}function et(e){switch(e.type){case\"Identifier\":return He(e);case\"Literal\":return qe(e);case\"FunctionExpression\":case\"ArrowFunctionExpression\":return Ke(e);case\"ClassExpression\":return Ge(e);case\"JSXElement\":return ze(e);case\"CallExpression\":return Qe(e);case\"ObjectExpression\":return oe(e);case\"ArrayExpression\":return Ze(e);default:return null}}function se(e){let t=We.parse(`(${e})`),r={inferredType:{type:\"Unknown\"},ast:t};if(t.body[0]!=null){let n=t.body[0];switch(n.type){case\"ExpressionStatement\":{let o=et(n.expression);o!=null&&(r=o);break}default:break}}return r}function l(e){try{return{...se(e)}}catch{}return{inferredType:{type:\"Unknown\"}}}var rt=150;function u({name:e,short:t,compact:r,full:n,inferredType:o}){return{name:e,short:t,compact:r,full:n??t,inferredType:o}}function ue(e){return e.replace(/PropTypes./g,\"\").replace(/.isRequired/g,\"\")}function ie(e){return e.split(/\\r?\\n/)}function j(e,t=!1){return ue(R(e,t))}function ae(e,t=!1){return ue(y(e,t))}function nt(e){switch(e){case\"Object\":return d;case\"Array\":return h;case\"Class\":return Z;case\"Function\":return f;case\"Element\":return m;default:return S}}function le(e,t){let{inferredType:r,ast:n}=l(e),{type:o}=r,s,a,c;switch(o){case\"Identifier\":case\"Literal\":s=e,a=e;break;case\"Object\":{let{depth:i}=r;s=d,a=i===1?j(n,!0):null,c=j(n);break}case\"Element\":{let{identifier:i}=r;s=i!=null&&!E(i)?i:m,a=ie(e).length===1?e:null,c=e;break}case\"Array\":{let{depth:i}=r;s=h,a=i<=2?ae(n,!0):null,c=ae(n);break}default:s=nt(o),a=ie(e).length===1?e:null,c=e;break}return u({name:t,short:s,compact:a,full:c,inferredType:o})}function ot({raw:e}){return e!=null?le(e,\"custom\"):u({name:\"custom\",short:S,compact:S})}function st(e){let{jsDocTags:t}=e;return t!=null&&(t.params!=null||t.returns!=null)?u({name:\"func\",short:z(t.params,t.returns),compact:null,full:G(t.params,t.returns)}):u({name:\"func\",short:f,compact:f})}function it(e,t){let r=Object.keys(e.value).map(a=>`${a}: ${P(e.value[a],t).full}`).join(\", \"),{inferredType:n,ast:o}=l(`{ ${r} }`),{depth:s}=n;return u({name:\"shape\",short:d,compact:s===1&&o?j(o,!0):null,full:o?j(o):null})}function w(e){return`objectOf(${e})`}function at(e,t){let{short:r,compact:n,full:o}=P(e.value,t);return u({name:\"objectOf\",short:w(r),compact:n!=null?w(n):null,full:o&&w(o)})}function pt(e,t){if(Array.isArray(e.value)){let r=e.value.reduce((n,o)=>{let{short:s,compact:a,full:c}=P(o,t);return n.short.push(s),n.compact.push(a),n.full.push(c),n},{short:[],compact:[],full:[]});return u({name:\"union\",short:r.short.join(\" | \"),compact:r.compact.every(n=>n!=null)?r.compact.join(\" | \"):null,full:r.full.join(\" | \")})}return u({name:\"union\",short:e.value,compact:null})}function ct({value:e,computed:t}){return t?le(e,\"enumvalue\"):u({name:\"enumvalue\",short:e,compact:e})}function ut(e){if(Array.isArray(e.value)){let t=e.value.reduce((r,n)=>{let{short:o,compact:s,full:a}=ct(n);return r.short.push(o),r.compact.push(s),r.full.push(a),r},{short:[],compact:[],full:[]});return u({name:\"enum\",short:t.short.join(\" | \"),compact:t.compact.every(r=>r!=null)?t.compact.join(\" | \"):null,full:t.full.join(\" | \")})}return u({name:\"enum\",short:e.value,compact:e.value})}function B(e){return`${e}[]`}function pe(e){return`[${e}]`}function ce(e,t,r){return u({name:\"arrayOf\",short:B(e),compact:t!=null?pe(t):null,full:r&&pe(r)})}function lt(e,t){let{name:r,short:n,compact:o,full:s,inferredType:a}=P(e.value,t);if(r===\"custom\"){if(a===\"Object\")return ce(n,o,s)}else if(r===\"shape\")return ce(n,o,s);return u({name:\"arrayOf\",short:B(n),compact:B(n)})}function P(e,t){try{switch(e.name){case\"custom\":return ot(e);case\"func\":return st(t);case\"shape\":return it(e,t);case\"instanceOf\":return u({name:\"instanceOf\",short:e.value,compact:e.value});case\"objectOf\":return at(e,t);case\"union\":return pt(e,t);case\"enum\":return ut(e);case\"arrayOf\":return lt(e,t);default:return u({name:e.name,short:e.name,compact:e.name})}}catch(r){console.error(r)}return u({name:\"unknown\",short:\"unknown\",compact:\"unknown\"})}function fe(e){let{type:t}=e.docgenInfo;if(t==null)return null;try{switch(t.name){case\"custom\":case\"shape\":case\"instanceOf\":case\"objectOf\":case\"union\":case\"enum\":case\"arrayOf\":{let{short:r,compact:n,full:o}=P(t,e);return n!=null&&!tt(n)?D(n):o?D(r,o):D(r)}case\"func\":{let{short:r,full:n}=P(t,e),o=r,s;return n&&n.length<rt?o=n:n&&(s=Q(n)),D(o,s)}default:return null}}catch(r){console.error(r)}return null}import{createSummaryValue as N,isTooLongForDefaultValueSummary as Te}from\"@storybook/docs-tools\";import{createSummaryValue as me,isTooLongForDefaultValueSummary as ft}from\"@storybook/docs-tools\";function J({inferredType:e,ast:t}){let{depth:r}=e;if(r===1){let n=R(t,!0);if(!ft(n))return me(n)}return me(d,R(t))}import{createSummaryValue as ye,isTooLongForDefaultValueSummary as mt}from\"@storybook/docs-tools\";function k({inferredType:e,ast:t}){let{depth:r}=e;if(r<=2){let n=_(t,!0);if(!mt(n))return ye(n)}return ye(h,_(t))}function A(e,t){return t?`${e}( ... )`:`${e}()`}function O(e){return`<${e} />`}function $(e){let{type:t,identifier:r}=e;switch(t){case\"Function\":return A(r,e.hasParams);case\"Element\":return O(r);default:return r}}function yt({inferredType:e,ast:t}){let{identifier:r}=e;if(r!=null)return N($(e),y(t));let n=y(t,!0);return Te(n)?N(f,y(t)):N(n)}function Tt(e,t){let{inferredType:r}=t,{identifier:n}=r;if(n!=null&&!E(n)){let o=$(r);return N(o,e)}return Te(e)?N(m,e):N(e)}function L(e){try{let t=l(e);switch(t.inferredType.type){case\"Object\":return J(t);case\"Function\":return yt(t);case\"Element\":return Tt(e,t);case\"Array\":return k(t);default:return null}}catch(t){console.error(t)}return null}import dt from\"lodash/isPlainObject\";import de from\"lodash/isFunction\";import gt from\"lodash/isString\";import ge from\"react-element-to-jsx-string\";import{createSummaryValue as T,isTooLongForDefaultValueSummary as It}from\"@storybook/docs-tools\";function Ie(e){return e.$$typeof!=null}function Y(e,t){let{name:r}=e;return r!==\"\"&&r!==\"anonymous\"&&r!==t?r:null}var Et=e=>T(JSON.stringify(e));function Pt(e){let{type:t}=e,{displayName:r}=t,n=ge(e,{});if(r!=null){let o=O(r);return T(o,n)}if(gt(t)&&E(t)){let s=ge(e,{tabStop:0}).replace(/\\r?\\n|\\r/g,\"\");if(!It(s))return T(s)}return T(m,n)}var Ot=e=>{if(Ie(e)&&e.type!=null)return Pt(e);if(dt(e)){let t=l(JSON.stringify(e));return J(t)}if(Array.isArray(e)){let t=l(JSON.stringify(e));return k(t)}return T(d)},Nt=(e,t)=>{let r=!1,n;if(de(e.render))r=!0;else if(e.prototype!=null&&de(e.prototype.render))r=!0;else{let s;try{n=l(e.toString());let{hasParams:a,params:c}=n.inferredType;a?c.length===1&&c[0].type===\"ObjectPattern\"&&(s=e({})):s=e(),s!=null&&Ie(s)&&(r=!0)}catch{}}let o=Y(e,t.name);if(o!=null){if(r)return T(O(o));n!=null&&(n=l(e.toString()));let{hasParams:s}=n.inferredType;return T(A(o,s))}return T(r?m:f)},xt=e=>T(e.toString()),Ee={string:Et,object:Ot,function:Nt,default:xt};function Pe(e={}){return{...Ee,...e}}function M(e,t,r=Ee){try{switch(typeof e){case\"string\":return r.string(e,t);case\"object\":return r.object(e,t);case\"function\":return r.function(e,t);default:return r.default(e,t)}}catch(n){console.error(n)}return null}function Oe(e,t){let{propTypes:r}=t;return r!=null?Object.keys(r).map(n=>e.find(o=>o.name===n)).filter(Boolean):e}import{createSummaryValue as X}from\"@storybook/docs-tools\";var ht=(e,{name:t,type:r})=>{let n=r.summary===\"element\"||r.summary===\"elementType\",o=Y(e,t);if(o!=null){if(n)return X(O(o));let{hasParams:s}=l(e.toString()).inferredType;return X(A(o,s))}return X(n?m:f)},Ne=Pe({function:ht});function Rt(e,t){let{propDef:r}=e,n=fe(e);n!=null&&(r.type=n);let{defaultValue:o}=e.docgenInfo;if(o!=null&&o.value!=null){let s=L(o.value);s!=null&&(r.defaultValue=s)}else if(t!=null){let s=M(t,r,Ne);s!=null&&(r.defaultValue=s)}return r}function xe(e,t){let r=t.defaultProps!=null?t.defaultProps:{},n=e.map(o=>Rt(o,r[o.propDef.name]));return Oe(n,t)}function Ct(e,t){let{propDef:r}=e,{defaultValue:n}=e.docgenInfo;if(n!=null&&n.value!=null){let o=L(n.value);o!=null&&(r.defaultValue=o)}else if(t!=null){let o=M(t,r);o!=null&&(r.defaultValue=o)}return r}function he(e){return e.map(t=>Ct(t))}var Ae=new Map;Object.keys(Re).forEach(e=>{let t=Re[e];Ae.set(t,e),Ae.set(t.isRequired,e)});function Ft(e,t){let r=e;!At(e)&&!e.propTypes&&F(e)&&(r=e.type);let n=St(r,t);if(n.length===0)return[];switch(n[0].typeSystem){case Ce.JAVASCRIPT:return xe(n,e);case Ce.TYPESCRIPT:return he(n);default:return n.map(o=>o.propDef)}}var Se=e=>({rows:Ft(e,\"props\")});var Fe=e=>{if(e){let{rows:t}=Se(e);if(t)return t.reduce((r,n)=>{let{name:o,description:s,type:a,sbType:c,defaultValue:i,jsDocTags:g,required:U}=n;return r[o]={name:o,description:s,type:{required:U,...c},table:{type:a,jsDocTags:g,defaultValue:i}},r},{})}return null};import W,{createElement as bt}from\"react\";import H from\"react-element-to-jsx-string\";import{dedent as Dt}from\"ts-dedent\";import jt from\"util-deprecate\";import{addons as Jt,useEffect as kt}from\"@storybook/addons\";import{SourceType as be,SNIPPET_RENDERED as Lt,getDocgenSection as Mt}from\"@storybook/docs-tools\";import{logger as V}from\"@storybook/client-logger\";var Vt=(e,t)=>typeof t.onBeforeRender!=\"function\"?e:jt(t.onBeforeRender,Dt`\n      StoryFn.parameters.jsx.onBeforeRender was deprecated.\n      Prefer StoryFn.parameters.jsx.transformSource instead.\n      See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-onbeforerender for details.\n    `)(e),Ut=(e,t,r)=>typeof t.transformSource!=\"function\"?e:t.transformSource(e,r),_t=(e,t)=>{if(typeof e>\"u\")return V.warn(\"Too many skip or undefined component\"),null;let r=e,n=r.type;for(let i=0;i<t.skip;i+=1){if(typeof r>\"u\")return V.warn(\"Cannot skip undefined element\"),null;if(W.Children.count(r)>1)return V.warn(\"Trying to skip an array of elements\"),null;typeof r.props.children>\"u\"?(V.warn(\"Not enough children to skip elements.\"),typeof r.type==\"function\"&&r.type.name===\"\"&&(r=W.createElement(n,{...r.props}))):typeof r.props.children==\"function\"?r=r.props.children():r=r.props.children}let a={...typeof t.displayName==\"string\"?{showFunctions:!0,displayName:()=>t.displayName}:{displayName:i=>i.type.displayName||Mt(i.type,\"displayName\")||(i.type.name!==\"_default\"?i.type.name:null)||(typeof i.type==\"function\"?\"No Display Name\":null)||(te(i.type)?i.type.render.name:null)||(F(i.type)?i.type.type.name:null)||i.type},...{filterProps:(i,g)=>i!==void 0},...t};return W.Children.map(e,i=>{let g=typeof i==\"number\"?i.toString():i,U=typeof H==\"function\"?H:H.default,x=Vt(U(g,a),t);if(x.indexOf(\"&quot;\")>-1){let q=x.match(/\\S+=\\\\\"([^\"]*)\\\\\"/g);q&&q.forEach(K=>{x=x.replace(K,K.replace(/&quot;/g,\"'\"))})}return x}).join(`\n`).replace(/function\\s+noRefCheck\\(\\)\\s+\\{\\}/,\"() => {}\")},vt={skip:0,showFunctions:!1,enableBeautify:!0,showDefaultProps:!1},wt=e=>{let t=e?.parameters.docs?.source,r=e?.parameters.__isArgsStory;return t?.type===be.DYNAMIC?!1:!r||t?.code||t?.type===be.CODE},Bt=e=>e.type?.displayName===\"MDXCreateElement\"&&!!e.props?.mdxType,De=e=>{if(!Bt(e))return e;let{mdxType:t,originalType:r,children:n,...o}=e.props,s=[];return n&&(s=(Array.isArray(n)?n:[n]).map(De)),bt(r,o,...s)},je=(e,t)=>{let r=Jt.getChannel(),n=wt(t),o=\"\";kt(()=>{n||r.emit(Lt,(t||{}).id,o)});let s=e();if(n)return s;let a={...vt,...t?.parameters.jsx||{}},c=t?.parameters.docs?.source?.excludeDecorators?t.originalStoryFn(t.args,t):s,i=De(c),g=_t(i,a);return g&&(o=Ut(g,a,t)),s};var Je={docs:{inlineStories:!0,extractArgTypes:Fe,extractComponentDescription:$t}},Xt=[je],Wt=[Yt];var To={framework:\"react\",...Je};export{Wt as argTypesEnhancers,Xt as decorators,To as parameters,ke as render,Le as renderToDOM};\n"],"names":[],"sourceRoot":""}